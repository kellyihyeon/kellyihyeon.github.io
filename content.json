{"posts":[{"title":"RESTful API - 리소스 이름은 어떻게 지어야할까?","text":"들어가며안녕하세요! 이번 글은 API의 리소스명을 어떻게 지어야하는지에 대한 고민 과정에 대해서 공유하고자 합니다.우선 제가 만들고 있는 서비스에 대해 간략하게 설명드릴게요. 저는 농구 동호회의 어드민 페이지를 만들고 있고 해당 서비스에서 필요한 기능은 크게 두 가지 입니다. 재무 관리 회원 관리 재무 관리 기능은 동호회 모임 통장과 관련한 기능인데요. 가계부 어플을 생각하면 이해하기 쉬울 거예요. 동호회 운영과 관련한 모든 재정적인 활동 내역을 기록하고 조회할 수 있는 기능입니다. 이 글에서는 재무 관리 기능에 대해서만 다룰 거예요.대쉬보드에 이달의 입금 &amp; 지출 내역 Top3 를 보여주고 싶습니다. 해당 API 엔드포인트를 설계하려고 해요. 그런데 리소스 이름을 어떻게 지어야 할까요? 도메인명으로 작성하면 되지 않나?입출금 내역으로 AccountTransaction 이라는 도메인을 사용하고 있어요. 그렇다면 이달의 입금 내역과 지출 내역을 조회하는 API를 설계할 때 /account-transactions 라는 리소스명을 사용하면 되지 않을까요? 아래와 같이 말이죠. 1. 이달의 입금 내역 상위 3개를 조회하는 API HTTP Method: GET Endpoint: /account-transactions/deposits/top3 Query Parameters: year: 조회할 연도 (예: 2024) month: 조회할 월 (예: 7) 2. 이달의 지출 내역 상위 3개를 조회하는 API HTTP Method: GET Endpoint: /account-transactions/expenses/top3 Query Parameters: year: 조회할 연도 (예: 2024) month: 조회할 월 (예: 7) 도메인의 관계가 이렇다면? 모임 통장에서 발생하고 있는 내역을 분류하면 위의 그림과 같아요. 입금 내역 A,B,C와 출금 내역 D,E 라고 설명하겠습니다. 입금 내역 A가 저장이 되면 입출금 내역에 A의 고유 ID와 트랜잭션 타입이 저장됩니다. 입금 내역 A를 조회하고 싶다면 A 테이블을 조회해서 데이터를 가져옵니다. 입출금 내역 테이블에 A의 데이터가 저장되어 있는 게 아니라 테이블의 속성으로 고유 ID와 트랜잭션 타입이 저장되어 있는데 이런 상황에도 /account-transactions 라는 리소스명을 사용해도 되는지 혼란이 왔습니다. API 사용자의 입장에서 생각해볼까?관점을 바꿔서 생각해봅시다. API 엔드포인트의 네이밍은 특정 도메인 객체가 직접적으로 데이터를 포함하고 있는지 여부보다는 리소스의 의미와 API 사용자에게 전달하는 메시지가 중요해요. /account-transactions 를 사용하는 API 사용자의 입장에서 해당 엔드포인트는 어떨까요? 계좌의 거래내역과 관련한 정보를 요청하고 있다 계좌 거래내역이 입금 및 출금과 관련한 메타데이터를 관리하고 있다 계좌 거래 내역의 입금 및 출금 데이터 중 상위 3개의 데이터를 반환한다 2024년, 7월을 파라미터로 전달한다면 2024년 7월 입금 및 출금 데이터 중에서 상위 3개의 데이터를 확인할 수 있다 원하는 결과값을 어느 테이블에서 들고 오느냐는 API 사용자의 관심사가 아닙니다. API 사용자가 원하는 결과값을 어떤 방식으로 구현하느냐는 API 제공자의 역할이에요. API 사용자는 결과값을 요청하는 것이 주된 관심사입니다.따라서 API를 설계할 때는 API 사용자에게 직관적이고 명확한 경험을 제공해주는 것이 중요합니다. 마무리하며API를 만들 때 했던 고민을 글로 정리해 보니 음… 별거 아니게 느껴지네요. 간단하게 결론이 지어졌어요. 사용자의 입장으로 돌아가자! 서비스의 요구사항들이 입출금 내역으로부터 파생되기 때문에 설계를 할 때도 너무 입출금 내역에만 중점을 뒀던 것 같아요.AccountTransaction 도메인은 처음엔 AccountBook 이었다가 AccountLog 가 되기도 했고 필요한 속성들도 수시로 바뀌었습니다. 도메인도 AccountTransaction(입출금 내역), Deposit(입금 내역), Withdrawal(출금 내역) 로 정했다가 계속해서 변경되었어요. 서비스의 요구사항과 목적을 제대로 정립하지 않아서 하나의 도메인이 여러 책임을 담당하게 되고 때문에 도메인의 변경이 잦아졌습니다. 그에따라 API 엔드포인트도 변경을 해야만 했어요. 서비스의 요구사항을 제대로 정립하기 위해선 도메인 탐구가 선행되어야겠다는 판단을 하게 됐습니다. 다음에는 도메인을 탐구하는 과정에서 생긴 일들을 공유하게 되면 좋겠습니다!","link":"/2024/09/04/%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%9D%B4%EB%A6%84%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A7%80%EC%96%B4%EC%95%BC%ED%95%A0%EA%B9%8C/"},{"title":"GitHub Pages와 Hexo로 기술 블로그 만들기","text":"블로그 시작하기구글링을 하다보면 종종 깃헙 블로그를 보게되는데 뭔가 만들기 어렵고 복잡할 것 같고 이상하게 개발자스러운 느낌이 들었어요. 나도 만들어보고 싶다는 생각’만’ 했었는데 ‘주1회 개발 블로그 작성하기!’ 다짐을 실행하기 위해 깃헙 블로그를 개설합니다. 깃헙 블로그를 사용하려는 이유 도전 정신 - 편의성이 정말 전혀 없어보이지만 그래서 오히려 한번 써보고 싶었어요. 티스토리나 벨로그같은 블로그 시스템은 게시물 등록이라는 행위로 블로그 작성이 끝이나지만, 깃헙 블로그는 하나부터 열까지 다 코드로 작성해야 한다는 얘기를 들어서 경험해보고 싶었어요. 깃헙 잔디 관리 - 기존에는 비쥬얼 스튜디오 코드를 이용해서 md 파일로 TIL를 작성하고 있었어요. 그러다가 팀원들과 공유해야 할 필요성 + 간편함 + 깔끔함을 느끼고 노션으로 갈아탔어요. 이왕 작성하는 TIL와 정보 공유글, 깃헙 블로그로 작성한다면 깃헙에 잔디도 심을 수 있으니 일석이조 아닌가! 라는 생각이 들었어요. 심미성 - 깃헙 + 프레임워크를 사용하면 다양한 테마를 고를 수 있다고 하여 찾아봤더니 마음에 드는 테마를 발견했습니다! 티스토리보다 훨씬 더 다양한 테마가 있어서 블로그를 꾸며보고 싶다는 생각이 들었어요. 꾸준히 작성해보려고 마음 먹은 거 이왕이면 디자인까지 내 마음에 드는 게 있으면 좋잖아요. 블로그 프레임워크정적 사이트를 만들 수 있는 블로그 프레임워크를 찾아보았고 Jekyll 와 Hexo 중에 어떤 걸 사용할지 고민하다가 Hexo 로 결정을 했어요. 두가지 프레임워크는 다음과 같은 특징을 가지고 있습니다. Jekyll 루비 기반 사용자가 가장 많음 테마가 다양함 Hexo 자바스크립트(Node js) 기반 문서화가 잘 되어 있음 테마가 다양함 깃헙 블로그로 구글링을 하면 깃헙 블로그 + Jekyll 조합이 많은데 저는 자바스크립트 기반의 Hexo 로 선택을 했어요. 루비에 대해서 전혀 모르기도 하고 회사에서 Node js 를 배울 기회가 있을 것 같아서 블로그 작성하면서 미리 찍먹해보려고요. Hexo 에서 제공해주는 테마를 구경하다가 마음에 드는 테마를 발견했어요. 테마 이름은 Matery 입니다. Matery 테마를 어떻게 내 블로그에 적용하고 배포하는지 알아보도록 합시다. Hexo 로 깃헙에 배포까지!Hexo 가 뭔가요?Documentation Hexo는 빠르고 간단하고 강력한 블로그 프레임워크예요. 마크다운이나 다른 마크업 언어로 게시글을 작성하면 Hexo 는 몇초만에 정적파일을 생성해줍니다. Hexo 설치하기Hexo를 설치하기 이전에 필요한 요구사항 Hexo를 설치하는 방법은 아주 쉽고 간단합니다. 아래와 같은 2가지 사항만 준비하면 돼요. 12﹒Node.js (최소한 Node.js 10.13 버전이 필요하고, 12.0 버전 이상을 추천합니다.)﹒Git Node.js 와 Git 이 이미 설치가 되어 있다면 바로 Hexo 설치하기 단계로 가시면 됩니다. (Git 설치는 생략하도록 하겠습니다.) Node.js 설치하기 Homebrew를 이용해서 Node.js를 설치합니다. node 설치가 성공적으로 끝났다면 아래의 명령어를 이용해서 node 버전을 확인해봅니다. 12$ brew install node$ npm -version Hexo 설치하기 모든 요구사항을 설치했다면 이제 npm 으로 Hexo를 설치할 수가 있습니다. 1$ npm install -g hexo-cli Hexo 초기화Hexo 가 설치 됐다면, 다음 명령어를 실행해서 에서 Hexo를 초기화해봅시다! 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 저는 디렉토리명을 ‘blog’로 해서 생성했어요. blog 디렉토리로 이동을 해서 리스트를 살펴보겠습니다. 1234$ ~/workspace ▶️ hexo init blog$ ~/workspace ▶️ cd blog$ ~/workspace/blog ▶️ ll$ ~/workspace/blog ▶️ npm install Hexo를 초기화 하고 나면, 프로젝트 폴더는 아래와 같은 구조로 되어있을 거예요. 제 blog 디렉토리 구조를 보시죠. 12345678_config.landscape.yml_config.ymlnode_modulespackage-lock.jsonpackage.jsonscaffoldssourcethemes _config.yml 수정_config.yml 은 사이트 환경설정 파일이에요. 우리는 여기에서 블로그에 대한 대부분의 세팅을 설정 할 수가 있어요. 몇가지 블로그 세팅을 한번 해볼게요! 환경설정 문서: https://hexo.io/docs/configuration 참고로 문서를 편집하기 위한 명령어는 아래와 같아요. vim 을 이용해서 yml 파일을 열어볼게요. 1$ blog ▶️ vim _config.yml Site내 블로그의 타이틀과 서브타이틀, 설명, 작성자를 수정해봅시다. 12345678# Sitetitle: 지식 보관소subtitle: '주요활동: 자료 수집 및 정돈'description: '필요할 때 꺼내쓰기 위해 잘 정리된 자료를 보관하는 곳'keywords:author: mynamelanguage: entimezone: '' URLURL 도 수정해보겠습니다. url 에는 내 깃헙 블로그 주소를 입력해주면 돼요. 1234567# URLurl: https://my_github_username.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 먼저 url 부분을 보면 내 깃헙 블로그 주소를 적어야 하는데 우선 username.github.io 라는 이름으로 깃헙 레포지토리를 생성해야 해요. (usrname 은 GitHub 계정의 username을 의미합니다.) 레포지토리 생성 후 해당 레포지토리의 주소를 url 부분에 적어주세요. DeploymentOne-command deployment해당 가이드는 https://hexo.io/docs/one-command-deployment 에서 가져온 내용이에요. Hexo는 빠르고 쉬운 배포 전략을 제공하고 있는데요, 내 블로그를 서버에 배포하려면 하나의 명령어만 입력하면 끝입니다. 1$ ~/workspace/blog ▶️ hexo deploy _config.yml 파일에 deploy 부분을 찾아서 실행시켜주는 명령어예요. 그러려면 deploy 부분이 먼저 정의되어 있어야겠죠. _config.yml 파일을 통해서 배포 설정을 할 수가 있습니다. 배포 구성요소에는 type 필드가 반드시 있어야 해요. 여러개의 배포 플러그인을 사용할 수도 있는데요 아래와 같이 type을 작성해주면 Hexo는 작성된 순서대로 플러그인을 실행시켜 줄 거예요. 12345deploy:- type: git repo:- type: heroku repo: GitGit 배포 플러그인을 사용하는 방법을 소개하겠습니다. hexo-deployer-git 을 설치해주세요. 1$ ~/workspace/blog ▶️ npm install hexo-deployer-git --save _config.yml 파일을 아래와 같이 수정해 봅시다. 12345deploy: type: git repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 예시를 살펴볼까요? Hexo 에서 배포할 때 어떤 레포지토리와 브랜치에 배포를 할 것인지를 설정해주었어요. $ hexo deploy 명령어를 실행하면 해당 레포지토리의 브랜치로 푸쉬가 됩니다. 1234deploy: type: git repo: https://github.com/username/username.github.io branch: main deploy 하기 위한 명령어를 입력해줍니다 12$ ~/workspace/blog ▶️ hexo clean$ ~/workspace/blog ▶️ hexo deploy 설정한 깃헙 레포지토리의 ‘Settings’ → ‘Pages’ 탭을 확인해봅니다. Branch 부분이 gh-pages로 되어있는지 확인하고, 그렇지 않다면 변경해줍니다. 블로그가 잘 만들어졌는지 웹페이지를 확인해봐야겠죠? username.github.io 로 접속해 확인해봅시다! 마치며 새로운 게시글을 등록하려면 매번 hexo clean → hexo deploy 명령어를 입력해야 합니다. GitHub Actions 를 사용해 배포 과정을 자동화할 수 있는 방법이 공식문서에 소개되어 있는데, 따라 만들어보면 좋을 것 같아요. main 브랜치와 gh-pages 브랜치를 나눠서 관리하는 방법으로 만들어보려다 처참히 실패하였습니다. gh-pages 브랜치에서 게시글 이력 관리를 할 수 있게끔 하고 main 브랜치에 수정 부분을 반영해서 관리하는 것 같은데, 이 부분은 추후에 다시 해보고 어떻게 고쳤는지 작성해보겠습니다. 튜토리얼을 보고 블로그를 만드는 데까지는 시간이 얼마 안걸렸지만 블로그 글로 정리 해보려고 하니 헷갈리는 부분이 많아 구글링 해보고 프로젝트 날렸다가 다시 만들어보고 하다보니 시간이….상당히 많이 걸리네요 ㅠㅠ….","link":"/2023/10/15/GitHub-Pages%EC%99%80-Hexo%EB%A1%9C-%EA%B8%B0%EC%88%A0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"order_by_후_group_by_를_하고_싶을_때","text":"단순 쿼리 해결 방법을 글로 남기는 이유group by 내부 정렬하는 방법을 구글링 한 게 이번이 처음이 아니기 때문입니다. 몇달 전에도 같은 문제로 구글링을 했고 동일한 해결 과정을 거쳤었어요. 구글링하면서 “아, 맞다! 맞다. 맞다. 아 이거 안되지 참….” 을 반복하면서 이건 정리를 하면서 공부해 놓고 넘어가야 다음에 또 반복 안하겠다는 생각이 들었습니다. 그동안 빨리 쿼리 짜서 원하는 데이터가 결과로 나오는 걸 확인하고 다음 스텝으로 넘어 갔었는데 시간 없다는 핑계로 계속 다음 다음만 했다가는 계속 이런 식으로만 개발할 것 같아서 잘 모르고 넘어갔던 빈틈을 채워보려고 합니다. 하고 싶은 것배치 로직을 개발해야 하는데 이에 필요한 데이터를 쿼리문으로 들고 와야해요. 필요한 데이터는 ‘보험 아이디 별 최신 데이터 한 건’ 입니다. 회사 데이터를 가져올 수가 없어서 제가 하고 싶은 쿼리를 뽑아낼 수 있는 샘플 데이터를 가지고 왔어요. 해당 케이스에서의 미션은 아래와 같습니다. ⭐️ 미션: product_code(상품코드)별 제일 최근에 등록된 데이터 가져오기 원하는 결과 샘플 데이터가 조금 고르지 못한데요. 미션을 성공하려면 id 가 1, 2, 3, 11, 7, 8, 9, 13, 14 번 데이터가 나와야해요. 나머지 데이터는 뒤로하고, 여기서 주의 깊게 봐야할 데이터는 product_code 가 406인 데이터와 378인 데이터입니다. 상품코드 406번의 로그를 보면 ‘상품 등록 → 수정 → 수정 → 수정’ 으로 제일 최근 데이터는 id 가 11번인 데이터 입니다. 상품코드 378번은 id가 13번인 데이터가 나와야 하구요. 왜… 왜 이렇게 나오는데…product_code 별로 created_at 을 최신순 정렬을 한 다음에 해당 데이터 row만 뽑으면 내가 원하는 결과를 가져올 수 있겠다 생각하고 쿼리를 짭니다. 쿼리는 아래와 같습니다. 1234SELECT id, product_code, log_value, created_at FROM product_sale_logGROUP BY product_codeORDER BY created_at DESC; 쿼리의 결과를 살펴볼까요? created_at 을 보면 데이터가 최신순으로 정렬되어 있는 것처럼 보이지만 제가 의도한 결과는 아닙니다. 전체 데이터를 최신순으로 정렬하는 게 아니라 일단 데이터를 product_code 별로 묶고, product_code 내에서 최신순으로 정렬한 결과 가장 최근의 데이터 행 하나를 원했던 것이었어요. GROUP BY는 된듯한데 GROUP BY 내에서 정렬은 일어나지 않은 것 같아요. 위의 결과는 product_code 별로 묶을 때 데이터베이스에 저장되어 있는대로 첫번째 row를 기준으로 묶어서 가져온 것이에요. 왜….? 왜 ORDER BY 는 싸그리 무시된 채 GROUP BY 만 적용이 된 걸까요…. query 가 실행되는 순서를 살펴봅시다. 해당 query 를 실행시키면 product_code 를 기준으로 GROUP BY 를 해요. 이 때 이미 각 product_code 별로 첫번째 행을 가져왔어요. 데이터 행에서 id, product_code, log_value, created_at 컬럼을 가져오고, 이렇게 구성된 데이터를 created_at 을 기준으로 ORDER BY 합니다. 그래서 데이터가 저렇게 나온 거죠. 작성한 쿼리대로 데이터는 잘 나왔어요. 1💡 쿼리가 실행되는 순서: **GROUP BY** -&gt; **ORDER BY** group by 내부 정렬하기왜 결과가 의도한 대로 나오지 않았는지 알았으니, 이제 원하는 결과를 뽑을 수 있는 쿼리를 짜보도록 합시다. 미션을 다시 떠올려보아요. ‘product_code(상품코드)별 제일 최근에 등록된 데이터 가져오기’ group by → order by 순으로 실행이 되니까 그럼… group by 하기 전에 created_at 컬럼을 최신순으로 order by를 해놓고 이렇게 정렬된 데이터를 대상으로 product_code 로 group by를 하면 원하는 결과가 나오지 않을까요? 쿼리문으로 한번 옮겨볼게요. 123SELECT id, product_code, log_value, created_at FROM (select * from product_sale_log order by created_at desc) as subGROUP BY product_code; 378번 상품코드와 406번 상품코드의 로그는 ‘상품 등록‘ 이에요. 네… 잘못되었습니다. 원하는 결과가 아니에요. FROM 절의 (select * from product_sale_log order by created_at desc) 해당 쿼리를 따로 뜯어서 실행시킨 것과 서브 쿼리 내에서 실행결과가 달라요. MySQL은 ORDER BY 가 서브쿼리 안에 있을 때 성능 이슈 문제 때문에 ORDER BY가 무시된다고 합니다. Rank() 와 Partition By() 사용하기반드시 GROUP BY 를 써서 해결을 해야할 필요가 없었기 때문에 다른 방법을 사용해서 해결하려고 합니다. 순위를 매기는 rank() 함수를 이용해서 product_code 별로 최신순으로 랭킹을 세우고, 랭킹이 1번인 데이터 행을 가져오게 하면 의도한 결과를 낼 수 있을 것 같아요. 해당 쿼리는 아래와 같습니다. 123456789SELECT id, product_code, log_value, created_atFROM ( select id, product_code, log_value, created_at, rank() over (partition by product_code order by created_at desc ) rank from product_sale_log ) testwhere rank = 1order by created_at desc; 상품코드 378번과 406번의 데이터를 보면 드디어 의도한 결과가 나온 것을 확인할 수 있습니다. select 에 rank 데이터도 확인해보면 랭킹이 1인 데이터를 가져온 것을 확인해볼 수가 있어요. 공부해봐야할 점 Order By 가 서브쿼리에 존재할 때 어떤 성능 이슈가 있는지 w3schools 에서 OrderDetails 테이블을 대상으로 쿼리 테스트를 했을 때는 서브쿼리에 order by 를 적용해서 만든 아래의 쿼리가 잘 적용이 되었어요. 왜 된 건지 그리고 지금 사용하고 있는 db 툴에서는 왜 안되는 건지. 어떨 때 되고 안되는지를 더 알아봐야 될 것 같습니다.","link":"/2023/10/30/order-by-%ED%9B%84-group-by-%EB%A5%BC-%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%84-%EB%95%8C/"}],"tags":[{"name":"RESTful-API","slug":"RESTful-API","link":"/tags/RESTful-API/"},{"name":"GitHub_Pages","slug":"GitHub-Pages","link":"/tags/GitHub-Pages/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"order-by","slug":"order-by","link":"/tags/order-by/"},{"name":"group-by","slug":"group-by","link":"/tags/group-by/"},{"name":"rank","slug":"rank","link":"/tags/rank/"},{"name":"partition-by","slug":"partition-by","link":"/tags/partition-by/"}],"categories":[{"name":"소프트웨어 아키텍처","slug":"소프트웨어-아키텍처","link":"/categories/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"데이터베이스","slug":"데이터베이스","link":"/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"}],"pages":[]}