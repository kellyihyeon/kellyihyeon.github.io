{"posts":[{"title":"chapter2. 데이터","text":"Question 0과 1로 숫자를 표현하는 방법 비트 이진법 이진수를 십진수로 변환할 때 이진수의 자리를 올림한다는 게 1과 0을 그냥 반대로 바꾼다는 뜻인가? 일상에서 사용하는 십진수가 있는데 십육진법이 왜 필요하지? 십육진법 이진수 ↔ 십육진수 변환하기 컴퓨터는 어떤 방법을 이용해서 사람이 이해할 수 있는 숫자를 표현해주고 있는 걸까? 0과 1로 문자를 표현하는 방법 인코딩, 디코딩 중 컴퓨터의 언어를 사람이 이해할 수 있는 언어로 변환하는 것은 어떤 걸까? 문자 집합character set 인코딩 디코딩 아스키 코드 아스키 코드 단점 EUC-KR 유니코드와 UTF-8 유니코드 유니코드는 아스키 코드나 EUC-KR과 어떤 점이 다른가? UTF-8 ‘한글’ 을 UTF-8로 인코딩한 값을 구하면? Reference Question 이진수를 십진수로 변환할 때 이진수의 자리를 올림한다는 게 1과 0을 그냥 반대로 바꾼다는 뜻인가? 이진수랑 십진수를 어떻게 서로 변환하는 걸까? 일상에서 사용하는 십진수가 있는데 십육진법이 왜 필요하지? 컴퓨터는 어떤 방법을 이용해서 사람이 이해할 수 있는 숫자를 표현해주고 있는 걸까? 인코딩, 디코딩 중 컴퓨터의 언어를 사람이 이해할 수 있는 언어로 변환하는 것은 어떤 걸까? 아스키코드, 유니코드, EUC-KR, UTF-8 개념을 확실하게 이해하고 넘어가자 1. 0과 1로 숫자를 표현하는 방법비트 컴퓨터가 이해하는 가장 작은 정보 단위 0과 1을 나타냄 → 두가지 정보를 표현할 수 있다 이진법 수학에서 0과 1만으로 모든 숫자를 표현하는 방법을 이진법이라고 한다 이진법을 이용하면 1보다 큰 수도 0과 1만으로 표현할 수 있다. 숫자가 1을 넘어가는 시점에 자리 올림을 하면 된다. 십진법이 숫자가 9를 넘어가는 시점에 자리 올림을 하듯이, 이진법은 숫자가 1을 넘어가는 시점에 자리 올림을 하여 0과 1 두 개의 숫자만으로 모든 수를 표현한다 이진수를 십진수로 변환할 때 이진수의 자리를 올림한다는 게 1과 0을 그냥 반대로 바꾼다는 뜻인가? 이진법이라는 게 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 모든 수를 표현하는 방법 이라는 것을 알게되었다. 이제 이진수를 십진수로 변환해보면서 해당 질문에 대한 답을 찾아가보자. 12345678910십진수 - 1 2 3 4 5 6 7 8이진수 - 1 (1을 넘어가는 시점이니 자리 올림) 10 11 (자리 올림) 100 101 (자리 올림) 110 111 (자리 올림) 1000 1과 0을 단순히 바꾸는 것이 아니라 숫자가 1을 넘어가는 시점이 되면 그 때 1 → 0 으로 올림이 되는 것이다. 10에서 0은 숫자가 1이 넘어가는 것이 아니니 0 → 1로 바꿔줘서 11이 되고 11은 숫자가 1이 넘어가니 1 → 0, 1 → 0 으로 올림이 되어 100이 된다. 일상에서 사용하는 십진수가 있는데 십육진법이 왜 필요하지?십육진법 이진법을 이용하면 0과 1만으로 모든 숫자를 표현할 수 있다. 하지만 0과 1만으로 모든 숫자를 표현하려니 숫자의 길이가 너무 길어진다는 단점이 생긴다. 그래서 이진법 이외에 십육진법도 자주 사용하고 있다. 십육진법은 수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식이다. 12십진수 - 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ...십육진수 - 0 1 2 3 4 5 6 7 8 9 A B C D E F 10 11 ... 15를 넘어가는 시점 F 에서 자리 올림을 한다. 십육진법을 사용하는 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기가 쉽기 때문이다. 이진수 ↔ 십육진수 변환하기 십육진수를 이진수로 변환할 때는 십육진수의 글자 하나하나를 4비트의 이진수로 간주하고 각각의 숫자를 이진수로 변환한 다음에 합치자. 이진수를 십육진수로 변화할 때는 이진수 숫자를 네 개 단위로 끊고, 네 개의 숫자를 십육진수로 변환한 다음에 합치자. 1A2B(16) 를 이진수로 변환하면? 1(2), A(2), 2(2), B(2) 로 끊고 0001(2), 1010(2), 0010(2), 1011(2) 각각 이진수로 변환 합치면 → 결과는 000110100010(2) 11010101(2) 를 십육진수로 변환하면? 1101(2), 0101(2) 네 개 단위로 끊고 십육진수로 변환하면 13 이니까 D(16), 5는 그대로 5(16) 합치면 → 결과는 D5(16) 컴퓨터는 어떤 방법을 이용해서 사람이 이해할 수 있는 숫자를 표현해주고 있는 걸까? 컴퓨터는 0과 1밖에 모르기 때문에 컴퓨터에 숫자를 알려주려면 이진수로 알려주어야 한다. 변환 과정을 거쳐 이진법으로 컴퓨터와 소통하게 된다. 2. 0과 1로 문자를 표현하는 방법인코딩, 디코딩 중 컴퓨터의 언어를 사람이 이해할 수 있는 언어로 변환하는 것은 어떤 걸까?문자 집합(character set) 컴퓨터가 인식할 수 있는 문자들의 모음 컴퓨터는 문자 집합에 속해 있지 않은 문자는 이해할 수 없다 인코딩 문자 집합에 있는 문자들을 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정 디코딩 0과 1로 표현된 문자 코드를 사람이 읽을 수 있는 문자로 변환하는 과정 아스키 코드 아스키 코드표 바로가기 영어 알파벳, 아라비아 숫자, 일부 특수 문자를 포함하는 문자 집합 하나의 아스키 문자를 나타내는 데 7비트를 사용하므로 7비트로 표현할 수 있는 정보는 2의 7승 즉 128개의 문자를 표현할 수 있다 아스키 문자들은 총 128개의 숫자 중 하나의 고유한 수에 일대일로 대응된다. 아스키 문자에 대응된 고유한 수를 아스키 코드라고 한다. 아스키 코드를 이진수로 표현하여 아스키 문자를 0과 1로 표현한다. 아스키 코드 단점 한글을 표현할 수 없고 아스키 문자 집합 외의 문자나 특수문자도 표현할 수 없다. 아스키 문자들은 7비트로 표현하기에 128개보다 많은 문자를 표현할 수 없다. EUC-KR 영어권 외의 나라들은 자신들의 언어를 0과 1로 표현할 수 있는 문자 집합과 인코딩 방식이 필요했기 때문에 이런 이유로 한글 인코딩 방식이 등장하게 되는데 이것이 EUC-KR 이다 방식 완성형 인코딩: 초성,중성,종성 조합의 한 글자에 고유한 코드를 부여하는 인코딩 방식 가: 1, 나:2, 다:3 … 조합형 인코딩: 초성, 중성, 종성에 해당하는 각각의 코드를 합해서 하나의 글자 코드를 만드는 인코딩 방식 ㄱ: 0010, ㅏ: 0011 … → 0010 0011 EUC-KR은 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식 아스키 코드보다 표현할 수 있는 문자는 많아졌지만 여전히 모든 한글 조합을 표현할 수는 없다 유니코드와 UTF-8유니코드 EUC-KR보다 훨씬 다양한 한글을 포함하며 대부분 나라의 문자, 특수문자, 화살표나 이모티콘까지도 코드로 표현할 수 있는 통일된 문자 집합 유니코드는 현대 문자를 표현할 때 가장 많이 사용되는 표준 문자 집합이다 유니코드 문자 집합에서는 아스키 코드나 EUC-KR과 같이 각 문자마다 고유한 값이 부여된다 유니코드는 아스키 코드나 EUC-KR과 어떤 점이 다른가? 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 삼았지만 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 다양한 방법으로 인코딩한다. 인코딩 방법에는 UTF-8, UTF-16, UTF-32 등이 있다. EUC-KR에서 ‘가’ 글자의 경우는 b0a1(16)이라는 고유한 값이 부여되고 b0a1 값으로 인코딩된다. 반면에 유니코드에서 ‘한’ 에 부여된 값은 D55C(16) 이고 이 값으로 그대로 인코딩 하지 않고 위의 방법으로 인코딩 한다. UTF-8 UTF는 Unicode Transformation Format 의 약어로 유니코드를 인코딩하는 방법이다. UTF-8은 통상 1바이트부터 4바이트까지의 인코딩 결과를 만들어 낸다. UTF-8로 인코딩한 결과가 몇 바이트가 될지는 유니코드 문자에 부여된 값의 범위에 따라 결정된다. ‘한글’ 을 UTF-8로 인코딩한 값을 구하면? ‘한에 부여된 값은 D55C(16), ‘글’에 부여된 값은 AE00(16) ‘한’ D55C(16) → 1101 0101 0101 1100(2) ‘글’ AE00(16) → 1010 1110 0000 0000(2) ‘한’ 과 ‘글’ 모두 0800(16) ~ FFFF(16) 사이에 있다. 0000 1000 0000 0000(2) ~ 1111 1111 1111 1111(2) 한글을 UTF-8로 인코딩하면 3바이트로 표현될 것이라 예상할 수 있다. 1과 0으로 표현된 자리는 고정이고, x표가 있는 자리에 유니코드 문자에 부여된 고유값이 들어간다. ‘한’ D55C(16) → 1101 0101 0101 1100(2), ‘글’ AE00(16) → 1010 1110 0000 0000(2) 이진수를 1110xxxx 10xxxxxx 10xxxxxx 에 각각 넣어보자 UTF-8 방식으로 인코딩한 결과는? 한 → 11101101 10010101 10011100(2) 글 → 11101010 10111000 10000000(2) Reference &lt;혼자 공부하는 컴퓨터 구조 + 운영체제&gt;","link":"/2024/03/16/chapter-2-data/"},{"title":"GitHub Page와 Hexo 로 기술 블로그 만들기","text":"블로그 시작하기구글링을 하다보면 종종 깃헙 블로그를 보게되는데 뭔가 만들기 어렵고 복잡할 것 같고 이상하게 개발자스러운 느낌이 들었어요. 나도 만들어보고 싶다는 생각’만’ 했었는데 ‘주1회 개발 블로그 작성하기!’ 다짐을 실행하기 위해 깃헙 블로그를 개설합니다. 깃헙 블로그를 사용하려는 이유 도전 정신 - 편의성이 정말 전혀 없어보이지만 그래서 오히려 한번 써보고 싶었어요. 티스토리나 벨로그같은 블로그 시스템은 게시물 등록이라는 행위로 블로그 작성이 끝이나지만, 깃헙 블로그는 하나부터 열까지 다 코드로 작성해야 한다는 얘기를 들어서 경험해보고 싶었어요. 깃헙 잔디 관리 - 기존에는 비쥬얼 스튜디오 코드를 이용해서 md 파일로 TIL를 작성하고 있었어요. 그러다가 팀원들과 공유해야 할 필요성 + 간편함 + 깔끔함을 느끼고 노션으로 갈아탔어요. 이왕 작성하는 TIL와 정보 공유글, 깃헙 블로그로 작성한다면 깃헙에 잔디도 심을 수 있으니 일석이조 아닌가! 라는 생각이 들었어요. 심미성 - 깃헙 + 프레임워크를 사용하면 다양한 테마를 고를 수 있다고 하여 찾아봤더니 마음에 드는 테마를 발견했습니다! 티스토리보다 훨씬 더 다양한 테마가 있어서 블로그를 꾸며보고 싶다는 생각이 들었어요. 꾸준히 작성해보려고 마음 먹은 거 이왕이면 디자인까지 내 마음에 드는 게 있으면 좋잖아요. 블로그 프레임워크정적 사이트를 만들 수 있는 블로그 프레임워크를 찾아보았고 Jekyll 와 Hexo 중에 어떤 걸 사용할지 고민하다가 Hexo 로 결정을 했어요. 두가지 프레임워크는 다음과 같은 특징을 가지고 있습니다. Jekyll 루비 기반 사용자가 가장 많음 테마가 다양함 Hexo 자바스크립트(Node js) 기반 문서화가 잘 되어 있음 테마가 다양함 깃헙 블로그로 구글링을 하면 깃헙 블로그 + Jekyll 조합이 많은데 저는 자바스크립트 기반의 Hexo 로 선택을 했어요. 루비에 대해서 전혀 모르기도 하고 회사에서 Node js 를 배울 기회가 있을 것 같아서 블로그 작성하면서 미리 찍먹해보려고요. Hexo 에서 제공해주는 테마를 구경하다가 마음에 드는 테마를 발견했어요. 테마 이름은 Matery 입니다. Matery 테마를 어떻게 내 블로그에 적용하고 배포하는지 알아보도록 합시다. Hexo 로 깃헙에 배포까지!Hexo 가 뭔가요?Documentation Hexo는 빠르고 간단하고 강력한 블로그 프레임워크예요. 마크다운이나 다른 마크업 언어로 게시글을 작성하면 Hexo 는 몇초만에 정적파일을 생성해줍니다. Hexo 설치하기Hexo를 설치하기 이전에 필요한 요구사항 Hexo를 설치하는 방법은 아주 쉽고 간단합니다. 아래와 같은 2가지 사항만 준비하면 돼요. 12﹒Node.js (최소한 Node.js 10.13 버전이 필요하고, 12.0 버전 이상을 추천합니다.)﹒Git Node.js 와 Git 이 이미 설치가 되어 있다면 바로 Hexo 설치하기 단계로 가시면 됩니다. (Git 설치는 생략하도록 하겠습니다.) Node.js 설치하기 Homebrew를 이용해서 Node.js를 설치합니다. node 설치가 성공적으로 끝났다면 아래의 명령어를 이용해서 node 버전을 확인해봅니다. 12$ brew install node$ npm -version Hexo 설치하기 모든 요구사항을 설치했다면 이제 npm 으로 Hexo를 설치할 수가 있습니다. 1$ npm install -g hexo-cli Hexo 초기화Hexo 가 설치 됐다면, 다음 명령어를 실행해서 에서 Hexo를 초기화해봅시다! 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 저는 디렉토리명을 ‘blog’로 해서 생성했어요. blog 디렉토리로 이동을 해서 리스트를 살펴보겠습니다. 1234$ ~/workspace ▶️ hexo init blog$ ~/workspace ▶️ cd blog$ ~/workspace/blog ▶️ ll$ ~/workspace/blog ▶️ npm install Hexo를 초기화 하고 나면, 프로젝트 폴더는 아래와 같은 구조로 되어있을 거예요. 제 blog 디렉토리 구조를 보시죠. 12345678_config.landscape.yml_config.ymlnode_modulespackage-lock.jsonpackage.jsonscaffoldssourcethemes _config.yml 수정_config.yml 은 사이트 환경설정 파일이에요. 우리는 여기에서 블로그에 대한 대부분의 세팅을 설정 할 수가 있어요. 몇가지 블로그 세팅을 한번 해볼게요! 환경설정 문서: https://hexo.io/docs/configuration 참고로 문서를 편집하기 위한 명령어는 아래와 같아요. vim 을 이용해서 yml 파일을 열어볼게요. 1$ blog ▶️ vim _config.yml Site내 블로그의 타이틀과 서브타이틀, 설명, 작성자를 수정해봅시다. 12345678# Sitetitle: 지식 보관소subtitle: '주요활동: 자료 수집 및 정돈'description: '필요할 때 꺼내쓰기 위해 잘 정리된 자료를 보관하는 곳'keywords:author: mynamelanguage: entimezone: '' URLURL 도 수정해보겠습니다. url 에는 내 깃헙 블로그 주소를 입력해주면 돼요. 1234567# URLurl: https://my_github_username.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 먼저 url 부분을 보면 내 깃헙 블로그 주소를 적어야 하는데 우선 username.github.io 라는 이름으로 깃헙 레포지토리를 생성해야 해요. (usrname 은 GitHub 계정의 username을 의미합니다.) 레포지토리 생성 후 해당 레포지토리의 주소를 url 부분에 적어주세요. DeploymentOne-command deployment해당 가이드는 https://hexo.io/docs/one-command-deployment 에서 가져온 내용이에요. Hexo는 빠르고 쉬운 배포 전략을 제공하고 있는데요, 내 블로그를 서버에 배포하려면 하나의 명령어만 입력하면 끝입니다. 1$ ~/workspace/blog ▶️ hexo deploy _config.yml 파일에 deploy 부분을 찾아서 실행시켜주는 명령어예요. 그러려면 deploy 부분이 먼저 정의되어 있어야겠죠. _config.yml 파일을 통해서 배포 설정을 할 수가 있습니다. 배포 구성요소에는 type 필드가 반드시 있어야 해요. 여러개의 배포 플러그인을 사용할 수도 있는데요 아래와 같이 type을 작성해주면 Hexo는 작성된 순서대로 플러그인을 실행시켜 줄 거예요. 12345deploy:- type: git repo:- type: heroku repo: GitGit 배포 플러그인을 사용하는 방법을 소개하겠습니다. hexo-deployer-git 을 설치해주세요. 1$ ~/workspace/blog ▶️ npm install hexo-deployer-git --save _config.yml 파일을 아래와 같이 수정해 봅시다. 12345deploy: type: git repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 예시를 살펴볼까요? Hexo 에서 배포할 때 어떤 레포지토리와 브랜치에 배포를 할 것인지를 설정해주었어요. $ hexo deploy 명령어를 실행하면 해당 레포지토리의 브랜치로 푸쉬가 됩니다. 1234deploy: type: git repo: https://github.com/username/username.github.io branch: main deploy 하기 위한 명령어를 입력해줍니다 12$ ~/workspace/blog ▶️ hexo clean$ ~/workspace/blog ▶️ hexo deploy 설정한 깃헙 레포지토리의 ‘Settings’ → ‘Pages’ 탭을 확인해봅니다. Branch 부분이 gh-pages로 되어있는지 확인하고, 그렇지 않다면 변경해줍니다. 블로그가 잘 만들어졌는지 웹페이지를 확인해봐야겠죠? username.github.io 로 접속해 확인해봅시다! 마치며 새로운 게시글을 등록하려면 매번 hexo clean → hexo deploy 명령어를 입력해야 합니다. GitHub Actions 를 사용해 배포 과정을 자동화할 수 있는 방법이 공식문서에 소개되어 있는데, 따라 만들어보면 좋을 것 같아요. main 브랜치와 gh-pages 브랜치를 나눠서 관리하는 방법으로 만들어보려다 처참히 실패하였습니다. gh-pages 브랜치에서 게시글 이력 관리를 할 수 있게끔 하고 main 브랜치에 수정 부분을 반영해서 관리하는 것 같은데, 이 부분은 추후에 다시 해보고 어떻게 고쳤는지 작성해보겠습니다. 튜토리얼을 보고 블로그를 만드는 데까지는 시간이 얼마 안걸렸지만 블로그 글로 정리 해보려고 하니 헷갈리는 부분이 많아 구글링 해보고 프로젝트 날렸다가 다시 만들어보고 하다보니 시간이….상당히 많이 걸리네요 ㅠㅠ….","link":"/2023/10/15/github-blog-and-hexo/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/10/15/hello-world/"},{"title":"order by 후 group by 를 하고 싶을 때","text":"단순 쿼리 해결 방법을 글로 남기는 이유group by 내부 정렬하는 방법을 구글링 한 게 이번이 처음이 아니기 때문입니다. 몇달 전에도 같은 문제로 구글링을 했고 동일한 해결 과정을 거쳤었어요. 구글링하면서 “아, 맞다! 맞다. 맞다. 아 이거 안되지 참….” 을 반복하면서 이건 정리를 하면서 공부해 놓고 넘어가야 다음에 또 반복 안하겠다는 생각이 들었습니다. 그동안 빨리 쿼리 짜서 원하는 데이터가 결과로 나오는 걸 확인하고 다음 스텝으로 넘어 갔었는데 시간 없다는 핑계로 계속 다음 다음만 했다가는 계속 이런 식으로만 개발할 것 같아서 잘 모르고 넘어갔던 빈틈을 채워보려고 합니다. 하고 싶은 것배치 로직을 개발해야 하는데 이에 필요한 데이터를 쿼리문으로 들고 와야해요. 필요한 데이터는 ‘보험 아이디 별 최신 데이터 한 건’ 입니다. 회사 데이터를 가져올 수가 없어서 제가 하고 싶은 쿼리를 뽑아낼 수 있는 샘플 데이터를 가지고 왔어요. 해당 케이스에서의 미션은 아래와 같습니다. ⭐️ 미션: product_code(상품코드)별 제일 최근에 등록된 데이터 가져오기 원하는 결과 샘플 데이터가 조금 고르지 못한데요. 미션을 성공하려면 id 가 1, 2, 3, 11, 7, 8, 9, 13, 14 번 데이터가 나와야해요. 나머지 데이터는 뒤로하고, 여기서 주의 깊게 봐야할 데이터는 product_code 가 406인 데이터와 378인 데이터입니다. 상품코드 406번의 로그를 보면 ‘상품 등록 → 수정 → 수정 → 수정’ 으로 제일 최근 데이터는 id 가 11번인 데이터 입니다. 상품코드 378번은 id가 13번인 데이터가 나와야 하구요. 왜… 왜 이렇게 나오는데…product_code 별로 created_at 을 최신순 정렬을 한 다음에 해당 데이터 row만 뽑으면 내가 원하는 결과를 가져올 수 있겠다 생각하고 쿼리를 짭니다. 쿼리는 아래와 같습니다. 1234SELECT id, product_code, log_value, created_at FROM product_sale_logGROUP BY product_codeORDER BY created_at DESC; 쿼리의 결과를 살펴볼까요? created_at 을 보면 데이터가 최신순으로 정렬되어 있는 것처럼 보이지만 제가 의도한 결과는 아닙니다. 전체 데이터를 최신순으로 정렬하는 게 아니라 일단 데이터를 product_code 별로 묶고, product_code 내에서 최신순으로 정렬한 결과 가장 최근의 데이터 행 하나를 원했던 것이었어요. GROUP BY는 된듯한데 GROUP BY 내에서 정렬은 일어나지 않은 것 같아요. 위의 결과는 product_code 별로 묶을 때 데이터베이스에 저장되어 있는대로 첫번째 row를 기준으로 묶어서 가져온 것이에요. 왜….? 왜 ORDER BY 는 싸그리 무시된 채 GROUP BY 만 적용이 된 걸까요…. query 가 실행되는 순서를 살펴봅시다. 해당 query 를 실행시키면 product_code 를 기준으로 GROUP BY 를 해요. 이 때 이미 각 product_code 별로 첫번째 행을 가져왔어요. 데이터 행에서 id, product_code, log_value, created_at 컬럼을 가져오고, 이렇게 구성된 데이터를 created_at 을 기준으로 ORDER BY 합니다. 그래서 데이터가 저렇게 나온 거죠. 작성한 쿼리대로 데이터는 잘 나왔어요. 1💡 쿼리가 실행되는 순서: **GROUP BY** -&gt; **ORDER BY** group by 내부 정렬하기왜 결과가 의도한 대로 나오지 않았는지 알았으니, 이제 원하는 결과를 뽑을 수 있는 쿼리를 짜보도록 합시다. 미션을 다시 떠올려보아요. ‘product_code(상품코드)별 제일 최근에 등록된 데이터 가져오기’ group by → order by 순으로 실행이 되니까 그럼… group by 하기 전에 created_at 컬럼을 최신순으로 order by를 해놓고 이렇게 정렬된 데이터를 대상으로 product_code 로 group by를 하면 원하는 결과가 나오지 않을까요? 쿼리문으로 한번 옮겨볼게요. 123SELECT id, product_code, log_value, created_at FROM (select * from product_sale_log order by created_at desc) as subGROUP BY product_code; 378번 상품코드와 406번 상품코드의 로그는 ‘상품 등록‘ 이에요. 네… 잘못되었습니다. 원하는 결과가 아니에요. FROM 절의 (select * from product_sale_log order by created_at desc) 해당 쿼리를 따로 뜯어서 실행시킨 것과 서브 쿼리 내에서 실행결과가 달라요. MySQL은 ORDER BY 가 서브쿼리 안에 있을 때 성능 이슈 문제 때문에 ORDER BY가 무시된다고 합니다. Rank() 와 Partition By() 사용하기반드시 GROUP BY 를 써서 해결을 해야할 필요가 없었기 때문에 다른 방법을 사용해서 해결하려고 합니다. 순위를 매기는 rank() 함수를 이용해서 product_code 별로 최신순으로 랭킹을 세우고, 랭킹이 1번인 데이터 행을 가져오게 하면 의도한 결과를 낼 수 있을 것 같아요. 해당 쿼리는 아래와 같습니다. 123456789SELECT id, product_code, log_value, created_atFROM ( select id, product_code, log_value, created_at, rank() over (partition by product_code order by created_at desc ) rank from product_sale_log ) testwhere rank = 1order by created_at desc; 상품코드 378번과 406번의 데이터를 보면 드디어 의도한 결과가 나온 것을 확인할 수 있습니다. select 에 rank 데이터도 확인해보면 랭킹이 1인 데이터를 가져온 것을 확인해볼 수가 있어요. 공부해봐야할 점 Order By 가 서브쿼리에 존재할 때 어떤 성능 이슈가 있는지 w3schools 에서 OrderDetails 테이블을 대상으로 쿼리 테스트를 했을 때는 서브쿼리에 order by 를 적용해서 만든 아래의 쿼리가 잘 적용이 되었어요. 왜 된 건지 그리고 지금 사용하고 있는 db 툴에서는 왜 안되는 건지. 어떨 때 되고 안되는지를 더 알아봐야 될 것 같습니다.","link":"/2023/10/30/mysql-rank-and-partition-by/"},{"title":"Object - 1.객체, 설계","text":"1. 티켓 판매 애플리케이션 구현하기이벤트에 당첨되어 초대권을 가지고 있는 관람객과 그렇지 못한 관람객에게 티켓을 판매하는 애플리케이션을 구현해야합니다. 초대권을 가지고 있는 관람객은 초대장을 티켓으로 교환한 후 입장하고 초대권을 가지고 있지 않은 관람객은 티켓을 구매해서 입장을 해야 합니다. 코드 설명이벤트 당첨자는 초대장을 가지고 있고, 이벤트에 당첨되지 않은 사람은 티켓을 구매할 현금을 가지고 있습니다. 관람객이 가지고 올 수 있는 물건은 현금, 초대장, 티켓 세가지가 있고 물건을 보관할 가방을 들고 올 수 있다고 가정합니다. Bag 인스턴스의 상태는 두가지가 될 수 있습니다. 이벤트에 당첨되지 않은 관람객은 티켓을 구매해야 하니 현금만 보관할 수 있고, 이벤트 당첨자는 초대장과 현금을 보관할 수 있습니다. 1234public class Invitation { private LocaldateTime when;} 12345678public class Ticket { private Long fee; public Long getFee() { return fee; } } 12345678910111213141516171819202122232425262728293031323334353637public class Bag { private Long amount: private Invitation invitation; private Ticket ticket; public Bag(long amount) { this(null, amount); } public Bag(Invitation invitation, long amount) { this.invitation = invitation; this.amount = amount; } public boolean hasInvitation() { return invitation != null; } public boolean hasTicket() { return ticket != null; } public void setTicket(Ticket ticket) { this.ticket = ticket; } public void minusAmount (Long amount) { this.amount -= amount; } public void plusAmount (Long amount) { this.amount += amount; }} 123456789101112public class Audience { private Bag bag; public Audience(Bag bag) { this.bag = bag; } public Bag getBag() { return bag; }} 관람객이 극장에 입장하려면 매표소를 거쳐야 합니다. 이벤트 당첨자는 매표소에서 초대장을 티켓으로 교환하고 그렇지 않은자는 티켓을 구매해야 합니다. 매표소는 관람객에게 판매할 티켓과 티켓의 판매금액을 보관하고 있습니다. 판매원은 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 하고 있습니다. 123456789101112131415161718192021222324public class TicketOffice { private Long amount; private List&lt;Ticket&gt; tickets = new ArrayList&lt;&gt;(); public TicketOffice(Long amount, Ticket . . . tickets) { this.amount = amount; this.tickets.addAll(Arrays.aslist(tickets)); } public Ticket getTicket() { return tickets.remove(0); } public void minusAmount (Long amount) { this.amount -= amount; } public void plusAmount(Long amount) { this.amount += amount; } } 123456789101112public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketoffice) { this.ticketoffice = ticketoffice; } public Ticketoffice getTicketOffice() { return ticketoffice; }} 해당 클래스들을 조합해서 극장이 관람객을 입장시키고 있는 로직입니다. 해당 코드를 살펴보면 극장은 관람객의 가방에 초대장이 있는지 확인을 합니다. 초대장이 들어 있으면 판매원에게서 티켓을 받아 관람객의 가방에 넣어줍니다. 가방에 초대장이 없는 경우에는 극장이 관람객의 가방에서 티켓 가격만큼 금액을 꺼내고나서 매표소에 티켓 가격만큼 금액을 증가시켜 놓습니다. 그리고 관람객의 가방에 티켓을 넣어줍니다. 1234567891011121314151617181920public class Theater { private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) { this.ticketSeller = ticketSeller; } public void enter (Audience audience) { if (audience.getBag().hasInvitation()) { Ticket ticket = ticketSeller.getTicketOffice().getTicket); audience.getBag().setTicket(ticket); } else { Ticket ticket = ticketSeller.getTicketOffice().getTicket(); audience.getBag().minusAmount(ticket.getFee()); ticketSeller.getTicketOffice().plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); } }} 애플리케이션 구현이 끝났습니다. 작성된 프로그램을 실행하면 의도대로 동작하는 것을 확인할 수 있습니다. 하지만 해당 프로그램에는 몇가지 문제점이 있는데 어떤 문제점이 있는지 살펴봅시다. 2. 구현한 애플리케이션의 문제점로버트 마틴이 소개한 소프트웨어 모듈이 가져야 하는 세 가지 기능을 적용하여 해당 어플리케이션이 어떤 문제점을 가지고 있는지 살펴보겠습니다. 1234소프트웨어 모듈이 가져야 하는 세 가지 목적첫번째, 실행 중에 제대로 동작하는 것두번째, 변경을 위해 존재하는 것세번째, 코드를 읽는 사람과 의사소통 하는 것 Theater 클래스의 enter 메서드가 하는 일을 살펴봅시다. 관람객의 가방에 초대장이 있는지 확인합니다. 초대장이 있다면 판매원이 매표소에서 티켓을 꺼내 관람객의 가방에 넣어줍니다. 가방에 초대장이 없다면 판매원은 관람객의 가방에서 티켓 금액만큼 현금을 꺼내고 매표소에 현금을 넣어 놓습니다. 그리고 매표소에서 티켓을 꺼내 관람객의 가방에 넣어줍니다. 문제점1. 관람객과 판매원은 수동적인 존재이다관람객의 관점에서 극장이 하는 일을 보면 자신의 가방을 마음대로 열어서 초대장을 확인하고 가방에 티켓을 넣어줍니다. 그리고 본인이 소유하고 있는 현금까지도 마음대로 빼가구요. 판매원의 관점에서도 마찬가지입니다. 극장은 자기가 일하는 매표소에서 티켓을 마음대로 빼가고 티켓 금액도 마음대로 넣어 놓습니다. 현실에서는 관람객이 가방에서 초대장을 꺼내 티켓과 교환합니다. 초대장이 없다면 현금을 내고 티켓을 구매합니다. 판매원은 자신이 일하는 매표소에서 관람객이 초대장을 주면 티켓으로 교환해주거나 티켓을 판매합니다. 코드에서 관람객과 판매원은 현실에서와 다르게 행동합니다. 코드 안에서 관람객과 판매원은 극장의 통제를 받는 수동적인 존재입니다. 그렇기 때문에 코드를 읽는 사람과 제대로 된 의사소통을 할 수가 없습니다. 문제점2. 극장은 모든 것을 기억해야 한다1234567891011public void enter (Audience audience) { if (audience.getBag().hasInvitation()) { Ticket ticket = ticketSeller.getTicketOffice().getTicket); audience.getBag().setTicket(ticket); } else { Ticket ticket = ticketSeller.getTicketOffice().getTicket(); audience.getBag().minusAmount(ticket.getFee()); ticketSeller.getTicketOffice().plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); } } 극장의 enter 메서드가 하는 일을 다시 보면서 극장이 알고 있는 사항을 나열해 봅시다. 관람객이 가방을 가지고 있다 가방에는 초대장과 티켓과 현금이 있다 판매원의 매표소에 티켓과 현금이 있다 극장 클래스의 enter 메서드는 이 모든 세부사항을 알고 있습니다. 때문에 하나의 메서드 안에서 극장에서 발생하는 모든 일들을 처리하고 있습니다. 모든 세부사항을 써내려간 코드는 작성자 뿐만 아니라 코드를 읽고 이해해야 하는 사람에게도 큰 부담이 됩니다. 문제점3. 가정이 바뀌면 모든 코드가 흔들린다관람객이 가방을 들고 있지 않거나 현금이 아닌 카드로 결제를 한다거나 판매원이 매표소가 아닌 곳에서 티켓을 판매한다면 코드에는 어떤 변화가 생길까요? Audience 클래스에서 Bag을 제거합니다. 그리고 Theater 의 enter 메서드에서도 Bag에 접근하고 있는 코드를 전부 제거해야 합니다. 판매원의 매표소 또한 마찬가지 입니다. enter 메서드에서 매표소에 접근하고 있는 코드를 찾아서 제거해야 합니다. Theater 클래스에서 Audience와 TicketSeller 의 세부적인 내용까지 전부 다 알고 있기 때문에, Audience와 TicketSeller에 변경이 일어나면 Theater 클래스까지 함께 변경해야 합니다. Theater 클래스가 두 클래스에 의존을 하고 있기 때문입니다. 객체 사이의 의존성이 높으면 결합도가 높다고 말합니다. 결국 의존성, 결합도는 변경과 관련이 있습니다. 객체 사이의 의존성, 결합도가 높으면 코드를 변경하기 어려워집니다. 3. 설계 개선하기예제 코드는 소프트웨어 모듈이 가져야하는 세가지 목적 중 한가지를 만족시킵니다. (실행 중에 제대로 동작하는 것) 하지만 변경하기가 어렵고, 코드를 읽는 사람이 이해하기가 어려워 의사소통 하는 데 문제가 있는 코드입니다. 두가지 목적도 만족시키기 위해서 코드를 개선해봅시다. 관람객과 판매원의 자율성을 높이자Theater가 Audience와 TicketSeller에 관한 세부적인 내용을 알지 못하도록 만듭니다. Theater는 Audience가 Bag을 가지고 있으며 Bag에는 어떤 것들이 있는지 알아야 할 필요가 없습니다. TicketSeller에 관한 세부적인 내용도 알 필요가 없죠. Theater의 관심사는 관람객이 극장에 입장하는 것입니다. 관람객이 가방에서 초대장을 티켓으로 교환하거나 티켓을 구매하게 만들고, 판매원이 자신이 일하는 매표소에서 티켓을 판매하고 티켓 금액을 처리하게 만들면 코드가 개선될 것입니다. Theater 의 enter 메서드에서 처리하고 있었던 해당 코드를 찾아서 각 객체 내부에 옮겨봅시다. 1234567891011121314151617181920public class Theater { private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) { this.ticketSeller = ticketSeller; } public void enter (Audience audience) {// if (audience.getBag().hasInvitation()) {// Ticket ticket = ticketSeller.getTicketOffice().getTicket);// audience.getBag().setTicket(ticket);// } else {// Ticket ticket = ticketSeller.getTicketOffice().getTicket();// audience.getBag().minusAmount(ticket.getFee());// ticketSeller.getTicketOffice().plusAmount(ticket.getFee());// audience.getBag().setTicket(ticket);// } }} 123456789101112131415161718192021222324public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketoffice) { this.ticketoffice = ticketoffice; }// public Ticketoffice getTicketOffice() { // return ticketoffice;// } public void sellTo(Audience audience) { if (audience.getBag().hasInvitation()) { Ticket ticket = ticketOffice.getTicket); audience.getBag().setTicket(ticket); } else { Ticket ticket = ticketOffice.getTicket); audience.getBag().minusAmount(ticket.getFee()); ticketOffice.plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); } }} enter 메서드에서 직접 TicketOffice에 접근하고 있던 코드를 전부 TicketSeller의 sellTo 메서드로 옮겼습니다. 이제 외부에서 TicketOffice에 직접 접근할 수 있는 방법이 없기 때문에 getTicketOffice 메서드는 제거가 되었습니다. TicketSeller 가 TicketOffice에서 티켓을 꺼내고 판매하고 티켓 금액을 처리할 수 있게 되었어요. 123**💡 이어지는 개념**캡슐화: 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것캡슐화의 목적: 객체 사이의 결합도를 낮추어 변경하기 쉬운 객체를 만드는 것 TicketSeller의 sellTo 메서드에서는 여전히 Audience 가 수동적인 존재입니다. 이번엔 TicketSeller가 Audience의 Bag에 직접 접근을 하고 있어요. 이번엔 Bag에 접근하는 코드를 전부 옮겨봅시다. 1234567891011121314151617181920212223public class Audience { private Bag bag; public Audience(Bag bag) { this.bag = bag; }// public Bag getBag() { // return bag;// } public Long buy(Ticket ticket) { if (bag.hasInvitation()) { bag.setTicket(ticket); return 0L; } else { bag.setTicket(ticket); bag.minusAmount(ticket.getFee()); return ticket.getFee(); } }} 이제는 Audience가 초대장이 있는지 스스로 확인할 수 있게 되었습니다. Audience가 Bag을 직접 처리하고 있기 때문에 외부에서는 Bag에 대한 접근을 할 수가 없도록 getBag 메서드를 제거하였습니다. 내부 구현을 캡슐화하였더니 객체들 사이의 결합도가 낮아졌습니다. 가정이 바뀌어도 Audience와 TicketSeller 의 코드 변경이 Theater에 영향을 미치지 않습니다. 123456789101112public class Theater { private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) { this.ticketSeller = ticketSeller; } public void enter (Audience audience) { ticketSeller.sellTo(audience); }} 123456789101112public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketoffice) { this.ticketoffice = ticketoffice; public void sellTo(Audience audience) { ticketoffice.plusAmount(audience.buy(ticketoffice.getTicket())); }} 12345678910111213141516171819public class Audience { private Bag bag; public Audience(Bag bag) { this.bag = bag; } public Long buy(Ticket ticket) { if (bag.hasInvitation()) { bag.setTicket(ticket); return 0L; } else { bag.setTicket(ticket); bag.minusAmount(ticket.getFee()); return ticket.getFee(); } }} 소프트웨어 모듈이 가져야 하는 세가지 목적을 다시 한번 살펴봅시다. 첫번째, 실행 중에 제대로 동작하는 것 두번째, 변경을 위해 존재하는 것 세번째, 코드를 읽는 사람과 의사소통 하는 것 기존 코드에서는 두번째, 세번째의 목적을 만족시키지 못했지만 수정된 코드는 이를 만족시킵니다. 캡슐화와 응집도Theater의 enter 메서드에서 Audience의 Bag 클래스, TicketSeller의 TicketOffice 클래스에 직접 접근 하고 있던 부분을 차단하고 Audience와 TicketSeller에서 직접 처리할 수 있게 하였습니다. Theater 클래스는 이제 더이상 Audience와 TicketSeller의 내부 구현에 대해서는 알지 못합니다. 그리고 객체들은 서로 메시지를 주고 받으며 의사소통 할 수 있게 되었습니다. 밀접하게 연관되어 있는 작업만 수행하고 연관성이 없는 작업은 다른 객체에게 위임하는 객체를 보고 응집도가 높다고 말합니다. 이는 즉 객체의 응집도를 높이려면 객체 스스로가 자신의 데이터를 책임져야 한다는 것을 의미합니다. 책임의 이동코드를 변경 하기 전의 절차적 설계에서는 Theater에 모든 책임이 있었습니다. enter 메서드에서 관람객이 극장에 입장하는 데 필요한 모든 절차를 처리하고 있었어요. 변경 후의 객체지향 설계에서는 각각의 객체가 자신이 맡은 일을 처리했습니다. Theater에 몰려 있던 책임이 개별 객체로 이동한 것입니다. 설계를 어렵게 만드는 것은 의존성입니다. 이 문제를 해결하기 위한 방법은 객체들 사이의 불필요한 의존성을 찾아내고 이를 제거해서 객체 사이의 결합도를 느슨하게 낮추어 놓는 것입니다. 예제 코드에서는 결합도를 낮추기 위해서 Audience와 TicketSeller 내부에 세부사항들을 캡슐화 하였습니다.","link":"/2023/11/12/object-1-object-and-design/"},{"title":"객체지향의 사실과 오해 - 추상화","text":"들어가며객체지향을 공부할 때 제일 이해가 안됐던 개념이 추상화 였어요. 공통으로 적용되는 것들을 모아놓은 것이 추상화구나 근데 객체지향이랑 추상화가 무슨 관련성이 있다는 거야? 를 이해하지 못한채 넘어갔어요. “객체지향을 얘기할 때 왜 항상 추상화 라는 개념이 나타날까? 이번엔 이해해보자”라고 다짐하며 해당 내용을 정리해보려 합니다. 추상화를 통한 복잡성 극복현실은 굉장히 복잡해요. 우리의 인지능력으로 이 모든 걸 그대로 받아들이기란 불가능 합니다. 그래서 초단순화 시키는 거죠. 본능이에요. 그리고 이게 바로 추상화입니다. 1추상화의 목적은 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것이다. 추상화는 복잡한 현실을 살아가는 인간이 본능적으로 발휘하는 인지 수단이라고 할 수 있어요. 여기까지가 인간 세계에서의 추상화였는데요. 그럼 이제 그래서 추상화가 객체지향이랑 무슨 상관인데? 를 파헤쳐봅시다. 객체지향과 추상화객체지향 패러다임은 객체를 이용해서 복잡성을 극복합니다. 책에서는 객체지향 패러다임 그리고 추상화 이 관계를 설명하기 위해서 이상한 나라의 앨리스의 한 장면을 예시로 들고 있어요. 우선 등장인물들만 가지고 와서 살펴보아요. 이야기에서 앨리스는 정원에 들어섰다가 정원사들을 만나게 돼요.정원사들은 트럼프처럼 생겼어요. 우리가 카드 게임할 때 등장하는 그 트럼프처럼요. 몸에는 스페이드 무늬가 있구요. 왕과 왕비, 공주와 왕자들, 병사들이 주르륵 나오는데 이들은 모두 트럼프처럼 생겼어요. 그리고 토끼도 등장합니다. 이 등장인물들의 생김새를 떠올리며 추상화를 이해해봅시다. 앨리스가 마주친 이들은 객체입니다. 각자 경계를 가지고 있고 식별이 가능해요. 왕, 왕비, 공주, 왕자, 병사, 정원사 한명 한명 식별이 가능해요. 하지만 앨리스는 이들을 모두 퉁쳐서 ‘트럼프’ 라고 칭합니다. 아! 토끼는 제외하구요 앨리스는 이들을 하나로 묶어 버렸어요. 각각의 객체들이 가지고 있는 특성은 무시하고 이들이 공통적으로 가지고 있는 모습만을 떠올리고 이들을 트럼프 라고 단순화했습니다. 앨리스는 추상화를 했어요. 앨리스는 이 모든 객체들을 트럼프 라고 말했습니다. 앨리스가 어떻게 추상화를 한 것일까요? 앨리스는 트럼프와 같은 외향을 가진 녀석들을 트럼프로 분류를 했고 여기에서 토끼는 제외시켰어요. 토끼는 토끼니까요. 트럼프로 묶어버리지 않았어요. 앨리스는 정원에 있는 이들을 트럼프 or 토끼 그룹으로 분류를 함으로써 복잡성을 단순화 시켰어요. 개념또다시 정원으로 돌아가봅시다. 정원에는 엄청나게 많은 객체들이 모여있어요. 이들을 하나하나 개별적인 인물들로 취급하면 어떻게 될까요…? 등장인물들 하나하나를 외우다가는 머리가 터져버리고 말 거예요… 그래서 앨리스가 이들을 그룹으로 분류를 했었죠. 앨리스는 이들을 공통점을 기반으로 묶어서 생각했어요. 이것이 개념입니다. 앨리스는 정원에 등장한 이들을 트럼프와 토끼 라는 개념을 이용해서 분류했어요. 12객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다. ‘객체는 개념 그룹에 포함되게 된다’라고 생각하면 이해하기가 더 쉬워요. 왕,왕비,정원사,병사….들은 트럼프라는 개념 그룹에 속하게 되고, 하얀 토끼는 토끼라는 개념 그룹에 속하게 돼요. 앨리스는 이 개념 그룹을 이용해서 객체들을 분류했어요. 분류는 객체지향에서 중요한 개념인데요. 어떤 객체를 어떤 개념으로 분류할지가 객체 지향의 핵심입니다. 객체를 적절한 개념 그룹에 넣지 못했다면 유지보수가 어려워지고 변경에 유연하게 대처할 수가 없어요 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구입니다. 타입타입은 개념입니다. 타입 == 개념 우리는 개념이라는 용어를 일상에서 잘 사용하고 있어요. 이 개념이라는 용어를 수학에서 차용해온 용어로 표현한 것이 타입 입니다. 그렇다면 타입도 공통점을 기반으로 객체들을 묶기 위한 틀 이라고 설명할 수 있어요. 1234타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다.어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다.타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다. 데이터 타입일단 컴퓨터의 세계로 들어가봅시다. 컴퓨터 메모리를 들여다보면 0과 1의 천국입니다. 0과 1밖에 없죠. 메모리 세계에서는 타입이 존재하지 않아요. 메모리에서 값을 하나 꺼내봅시다. 010101011101100 을 꺼내보죠. 제가 꺼낸 데이터를 해석해 봅시다. 숫자인가요? 문자열인가요? 그것도 아니면 메모리 상에 저장되어 있는 특정 주소값 일까요? 해석을 할 수가 없습니다. 그래서 사람들은 데이터를 용도에 따라 분류 하기로 했고 그래서 숫자형, 문자열형, 논리형 등등이 생겨났어요. 시스템이 갖춰진 것이죠. 12데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수해오딜 수 있는지를 결정한다. 객체와 타입객체를 타입으로 분류했던 앨리스를 떠올려봅시다. 객체를 타입으로 분류하고 해당 타입에 이름을 붙이던 앨리스. 개발자가 하고 있는 일 아닌가요? 여기에서 핵심 내용을 다시 상기시켜봅시다. 객체를 만들어낼 때 가장 중요하게 고려해야 하는 것은 행동 입니다. 상태가 아니라 행동이에요. 객체가 다른 객체와 협력하기 위해서 어떤 행동을 해야 하는가? 에 대한 고민을 먼저 해야 합니다. 이것을 결정하는 것이 객체지향 설계의 핵심이니까요. 123451. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다. 객체가 어떤 데이터를 갖고 있는가는 우리의 관심 대상이 아니에요. 객체가 어떤 행동을 하는가를 기준으로 동일한 행동을 하는 객체라면 서로 다른 데이터를 가지더라도 하나의 타입으로 분류할 수 있습니다. 서로 다른 데이터를 가지고 있더라도 동일한 메시지를 받고 이를 처리할 수 있어요. 다만 그 메시지를 처리하는 방법은 각자 다를 수 있겠죠. 여기에서 나오는 개념이 있는데요. 바로 다형성 입니다. 다형성은 동일한 메시지를 서로 다른 방식으로 처리할 수 있는 능력을 의미해요. 그리고 데이터가 아니라 객체의 행동만이 우리의 관심사라는 의미를 다시 생각해보면 이 말은 즉, 외부에 행동만 제공하고 데이터는 감춰야 한다는 것을 의미해요. 이 원칙을 우리는 캡슐화 라고 하지요. 앨리스가 왕, 여왕, 공주, 왕자들을 트럼프로 분류한 이유를 생각해봅시다. 이들은 모두 동일한 행동을 하기 때문이에요. 이들의 행동을 살펴봅시다. 123몸이 납작해서 종이처럼 납작 엎드릴 수 있다.바람에 뒤집어 질 수 있다.네모 귀퉁이에 손과 발이 달렸다. 그래서 걸을 때 몸이 펄럭거린다. 앨리스는 이들의 행동을 기준으로 트럼프로 분류했어요. 객체를 결정하는 것은 행동입니다. 데이터는 행동을 따를 뿐이에요. 이것이 객체지향의 핵심적인 원칙이에요. 마치며제일 이해가 안갔던 추상화 부분을 다시한번 읽어보면서 느꼈던 점은 객체의 행동을 중점에 두고 객체를 바라보면 추상화의 개념이 절로 따라온다 라는 것이었어요. 다형성이라는 개념도 객체의 행동을 놓고 객체를 분류했을 때 나올 수밖에 없는 개념이었구요. 평소 코드를 짤 때를 떠올려보니 클래스를 정의할 때 데이터를 먼저 정의하고 행동을 생각하다보니 데이터를 중심으로 행동이 맞춰져 가는 코드를 짰었던 것 같다는 생각이 들었어요. 객체들이 서로 메시지를 주고 받는 형태로 협력을 이루게 해야 하는데 메시지가 아닌 데이터를 어떻게 옮길 것인가를 중점으로 생각했던 것 같고 그래서 인터페이스를 잘 활용하지 못했던 것도 같아요. 책임 주도 설계 방법을 잘 적용해서 코드를 짜보고 이전에 짰던 코드랑 비교해서 보면 어떨지 궁금해져요.","link":"/2023/11/05/the-essence-of-object-orientation-abstraction-md/"},{"title":"객체지향의 사실과 오해 - 객체편","text":"이 책을 고른 이유취준생 시절에 읽었었던 책이지만 머리에 남아있는 게 없어서 다시 한번 읽어보려고 이 책을 선택했어요. 개발자로 일하고 있는 지금 이 책을 읽었을 때 이해도가 많이 다를까 궁금하기도 해서 내 상황에 맞게 예시를 적용해가며 책을 읽어가던 중 핵심적인 부분은 내용을 정리해 놓고 주기적으로 다시 살펴보면 좋을 것 같아서 글로 정리를 해보려 합니다. 이상한 나라의 객체현실세계에서의 객체지금 당장 제 주변에 있는 객체를 말해보라고 한다면? 저는 노트북, 책, 독서대, 컵, 휴대폰, 안경 케이스, 이어폰, 커피머신 이라고 말할 수 있어요. 눈에 보이는 더 많은 객체들을 말할 수가 있는데요. 이렇게 하나의 단위로 인식할 수 있고 다른 사물과 구분할 수 있는 것들을 객체라고 부릅니다. 그리고 인간은 이 이상을 넘어 개념적으로 경계 지을 수 있는 추상적인 사물까지도 객체로 인식할 수가 있어요. 예를 들어볼게요, 제가 지금 열심히 참여하고 있는 농구 클래스의 출석 명단을 예로 들 수 있을 거 같아요. 회원들은 저번주 출석 명단과 이번주 출석 명단을 구분할 수 있고, 저번주와 이번주의 출석률도 비교할 수 있어요. 같은 회원이 저번주와 이번주에 모두 참여한다고 하더라도 두 출석 명단을 구분하고 비교하는 일은 아주 쉽습니다. 출석과 출석률은 물리적인 실체가 없지만 우리는 이를 쉽게 구분할 수 있고 하나의 단위로 인식할 수 있는 개념적인 객체라고 볼 수 있어요. 💡 요약해보면, 객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것 입니다. 객체지향 나라에서의 객체책에서 객체를 어떻게 정의를 하고 있는지 살펴보면 아래와 같아요. 1234객체란 식별 가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다.객체는 구별 가능한 **식별자**, 특징적인 **행동**, 변경 가능한 **상태**를 가진다.소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다. 객체를 설명하는 데 중요한 3가지 키워드가 나와있는데요, ‘식별자, 행동, 상태’ 이 개념들을 알아볼까요? 상태객체가 왜 상태를 가지고 있어야 하는지 그 필요성에 대해서 생각해보아요. 객체는 주변 환경에 어떻게 반응할까요? 객체가 어떻게 반응할 것인지는 객체가 행동을 결정하려는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우됩니다. 예를 들어서 설명해 볼게요. H는 농구 클래스 수업을 듣고 있고 또 어느 농구 팀에 소속되어 있습니다. 농구 클래스는 레벨이 5까지 있고, 하위 레벨로 이동하는 것은 제약이 없지만 상위 레벨로 가려면 각 레벨 테스트에 통과를 해야합니다. 이 예시에서 출발해보도록 합시다. 농구 클래스 수업을 들으려면 수업 시작일 전까지 해당 레벨 클래스를 결제해야 합니다. 클래스를 결제하기 위해서는 사이트에 회원가입을 먼저 해야 하고요. 이렇듯 어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존하고 있어요. ‘H가 농구 클래스를 듣는다’ 라는 행동의 결과를 예상할 수 있는 한 가지 방법은 H가 과거 해당 클래스를 결제한 적이 있는지를 살펴보는 것인데요. 이 방법의 단점이 있습니다. 복잡해요. H가 과거에 했던 모든 행동을 타고타고 내려가서 과거의 행동 이력을 기억해야 하기 때문에 이 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 우선 복잡합니다. 그리고 너무 번거로워요. 이 점을 단순하게 풀어내기 위해 상태라는 개념이 나오게 됩니다. 다시 예로 돌아가보죠. H의 클래스 수강 가능 여부는 H의 클래스 결제 상태를 보고 예측할 수 있습니다. 과거의 이력을 기억하지 않아도 돼요. 결제 상태가 YES 이기만 하면 되는 거죠. 조금 더 구체적으로 예를 들어 H의 현재 레벨이 5라고 가정해봅시다. 레벨 5는 레벨 4를 3개월 이상 수강해야만 올라갈 수 있습니다. H가 레벨 5 클래스를 수강하고 있다는 행동의 결과는 H가 과거에 어떤 행동을 했었는지는 몰라도 되는 거죠. H의 현재 레벨 상태와 해당 클래스의 수강 기간 상태라는 두 가지 상태만 알면 H가 레벨 5 클래스를 듣는 행동의 결과를 쉽게 예측할 수 있어요. 12상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.상태는 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다. 상태와 프로퍼티 상태를 설명할 때 예로 든 개념을 다시 살펴볼게요. 첫번째로 H는 객체입니다. 그리고 H가 구매한 농구 클래스 역시 객체입니다. H가 소속되어 있는 팀 역시 객체입니다. H &amp; 농구 클래스 &amp; 소속팀은 제각각 뚜렷한 경계를 가지고 있어요. 식별이 가능하고 상태와 행동을 모두 가지고 있습니다. 하지만 H의 ‘레벨 상태’와 ‘테스트 통과 여부’ 는 어떨까요? 이들 역시도 제각각 뚜렷한 경계를 가지고 있고 식별이 가능합니다. 하지만 객체가 아닙니다. 숫자, 문자열, 시간, 날짜 참/거짓과 같은 단순한 값들은 객체가 아니에요. 단순한 값들은 다른 객체의 상태를 표현하기 위해 사용되기 때문이에요. H의 레벨 상태는 단순한 숫자 값으로 표현할 수 있어요. 테스트 통과 여부는 참/거짓으로 표현할 수 있고, H의 수강 기간은 날짜 혹은 시간으로 표현할 수 있어요. 이들은 객체는 아니지만 객체의 상태를 표현하고 있습니다. 이번엔 H가 어떤 클래스를 수강하고 있는지를 표현해보도록 해요. 어떻게 표현해야 할까요? 제일 간단하게 표현하는 방법은 H의 상태 일부를 농구 클래스 수강권 객체를 이용해 표현하는 것입니다. H와 농구 클래스를 연결시키는 것이죠. 객체지향 관점에서 ‘연결’ 이라는 것은 ‘알고 있다’ 라는 의미로 사용을 합니다. H와 농구 클래스를 연결하면 아래의 그림과 같아요. H와 농구 클래스 수강권은 객체 입니다. 하지만 H의 레벨과 테스트 통과 여부, 농구 클래스의 레벨과 가격은 객체가 아니라 단순한 값에 불과해요. 상태 얘기를 하면서 객체와 단순한 값 그리고 또 다른 객체 얘기를 늘어놓고 있는데요. 정리를 해보자면 H의 상태는 레벨과 테스트 통과 여부라는 단순한 값과 농구 클래스라는 객체의 조합으로 표현할 수 있어요. 그림을 딱 보고 H의 상태를 이렇게 설명할 수 있어요.”H는 현재 레벨이 4이고 테스트를 통과하였으며 2023년 10월 1일 ~ 31일까지 유효한 10만원 짜리 레벨 5 농구 클래스 수강권을 가지고 있다.” 12모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있다. 이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다. H의 프로퍼티를 찾아볼까요? H의 현재 레벨, 테스트 통과 여부, 농구 클래스 수강권. 이들을 프로퍼티라고 불러요. 그렇다면 5, false, 100000, 2023.10.01, 2023.10.31 같은 단순한 값들은 뭐라고 불러야 할까요? 이들을 프로퍼티 값(property value) 이라고 부릅니다. 프로퍼티 값은 시간이 흐르면 변경되는 값이기 때문에 동적입니다. 프로퍼티는 시간이 흘러도 변경되지 않고 고정되기 때문에 정적이고요. 시간이 흐르면 값이 변경된다? 다른 시점에서 H의 상태를 한번 살펴보도록 합시다. H는 레벨 5가 되었지만 테스트는 통과하지 못했어요. 그리고 지금은 농구 클래스를 수강하고 있지 않은 것 같아요. 클래스를 수강하고 있냐 아니냐는 선의 여부를 보면 알 수 있어요. H 객체와 농구 클래스 수강권 객체 사이가 연결이 되어 있었는데 위의 그림에서는 연결이 되어 있지 않아요. 우리는 이 연결을 객체가 다른 객체를 ‘알고 있다’ 라고 표현해요. 그리고 이 연결은 중요한데요. 객체와 객체 사이에 연결이 되어 있어야 다른 객체에게 메세지를 요청할 수가 있기 때문이에요. 연결은 다른 객체를 참조할 수 있다는 것을 의미하고 이는 즉, 다른 객체의 식별자를 알고 있는 것을 의미합니다. 그리고 위에서 설명한 단순한 값에 불과한 H의 레벨과 테스트 통과 여부, 농구 클래스 수강권의 가격 등등을 속성(attribute) 이라고 부릅니다. 1객체의 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두 가지 종류의 조합으로 표현할 수 있다. 행동객체는 자율적인 존재입니다. 객체 스스로 행동해서 자신의 상태를 변경합니다. 외부 객체는 절대로 직접적으로 다른 객체의 상태를 멋대로 변경할 수 없습니다. 하지만 우리에게 주어진 문제를 해결하기 위해서는 객체와 객체가 서로 협력 해야만 해결할 수 있는데요. 이를 위해 외부 객체가 간접적으로 다른 객체의 상태를 변경하거나 볼 수 있는 방법이 필요합니다. 그래서 행동 이라는 개념이 나타난 것이죠. 객체의 상태를 설명하면서 다른 객체에게 메세지를 요청 한다고 언급한 적이 있습니다. 객체가 다른 객체와 협력하는 방법이 메세지를 요청하는 것입니다. 메세지를 통해서만 협력할 수 있어요. 복잡한 문제를 해결하기 위해서는 객체가 다른 객체에게 메세지를 요청하면서 연쇄 요청 작업이 일어나게 되는데요. 메세지를 수신한 객체는 메세지를 읽고 협력에 참여할 것인지, 참여한다면 어떤 방법으로 해당 메세지에 대한 응답을 줄 것인지를 스스로 결정하게 됩니다. 행동을 함으로써 자신의 상태를 변경하는 것이죠. 123행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다.행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 베시지를 전달 할 수 있다.객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다. 상태 캡슐화 객체지향 나라에서의 객체와 현실의 객체 사이에서 중요한 차이점은 객체의 자율화입니다. 현실에서 H와 수강권 중에 능동적인 주체를 택하라 한다면 당연히 H를 택할 거예요. 수강을 할지 말지는 H의 의지이며 H가 수강하기로 했다면 수강권을 결제하는 주체 또한 H이기 때문이죠.그렇다면 객체지향 나라에서 능동적인 주체는 누구일까요? 모든 객체입니다.H의 레벨 상태와 테스트 통과여부를 결정하는 주체는 H 입니다. 수강권 객체도 마찬가지인데요. 수강권 객체는 H로부터 메세지를 요청 받으면 발권 여부를 스스로 결정합니다. 발권 시 시작일과 종료일 또한 스스로 설정하여 메세지에 대한 응답을 돌려줍니다. 발권을 할지 말지는 수강권 객체 스스로가 결정할 사항이며 H 객체가 발권 행위에 직접 개입할 수 없습니다. H 객체는 수강권 객체에 자신의 레벨 상태를 전달하고 응답을 기다리는 역할을 할 뿐이에요. H 객체와 수강권 객체 사이에 어떤 메세지가 오고가는지 살펴볼까요? H 객체에게는 doLevelTest() 라는 메세지가 요청이 되었고, 수강권 객체 에게는 doneLevelTest(level) 라는 메세지가 요청이 되었어요. 메세지를 요청한 객체 입장에서 생각해 봅시다. 메세지를 전달하였으니 어떤 상태가 변경되겠지? 라고 예상할 수 있을까요? 전혀 예상할 수가 없습니다. H의 레벨과 테스트 통과여부가 어떻게 변경되었는지, 수강권은 또 어떻게 변했는지 알 수 없어요. 사실 메세지를 전달했을 때 상태가 변경될 거라는 사실조차 알 수가 없어요. 이게 바로 캡슐화 입니다! 12345객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다.객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.이것이 상태를 캡슐화해야 하는 이유다. 식별자개념적인 객체를 설명하면서 예시로 든 출석 명단을 생각해봅시다. 지난주의 출석 명단과 이번주의 출석 명단은 같은 출석 명단 객체입니다. 이 두 객체를 서로 어떻게 구별할까요? 이때 나오는 개념이 식별자 입니다. 객체를 식별할 수 있다는 것은 두 객체가 서로 다른 객체임을 구별할 수 있는 프로퍼티가 객체 내부에 있다는 의미입니다. 이 프로퍼티를 식별자라고 불러요. 객체들은 식별자를 가지고 있고, 식별자로 서로를 구별할 수 있습니다. 여기에서 단순한 값과 객체의 차이점이 생기는데요. 단순한 값은 식별자를 가지지 않아요. 중요한 차이점 입니다. 단순한 값과 객체의 차이점에 대해서 좀 더 살펴봅시다. 단순한 값 값의 상태는 변하지 않기 때문에 불변 상태를 가진다고 말합니다. 값이 같은지를 판단할 때는 상태를 기준으로 판단해요. 값의 상태가 예를 들어 1이라고 한다면, 1 = 1은 같기 때문에 두 인스턴스를 같은 것으로 판단합니다. 상태를 이용해서 두 값이 같은지 판단할 수 있는 성질을 동등성(equality) 이라고 해요. 상태로 판단할 수 있는 이유는 상태는 변하지 않기 때문이죠. 이처럼 값은 상태를 이용해 동등성을 판단하기 때문에 인스턴스를 구별하기 위해서 식별자가 필요하지 않아요. 객체 객체는 시간에 따라 상태가 변경되기 때문에 가변 상태를 가진다고 말합니다. H 로 예를 들어볼게요. H와 상태가 완전히 똑같은 S 가 있습니다. H와 S의 상태는 완전히 동일한데요. 그렇다면 두 회원은 동일인물 인가요? 완전 다른 사람이죠. 그리고 시간이 지난다면 어떻게 될까요? 그 때도 완전히 동일한 상태일 거라고 확신할 수 있을까요? 변할 수 있겠죠. 때문에 객체는 식별자가 필요해요. H와 S의 상태가 같더라도 식별자를 보고 두 객체는 다르다 라고 말할 수 있어요. 아래의 그림을 보면서 반대의 경우도 생각해볼까요? 두 객체의 상태가 다르죠. 이 두 객체는 서로 다른 객체일까요? 그림만 보고서는 알 수가 없어요. 식별자를 봐야해요. 식별자가 같으면 두 객체는 같은 객체입니다. 식별자를 이용해서 객체가 같은지 판단할 수 있는 성질을 동일성(identical) 이라고 해요. 💡 용어 정리 값 객체(String, Integer, Long…)는 식별자를 가지지 않기 때문에 여기에서 언급하는 객체란 참조 객체(reference object) 를 의미합니다. 마치며취준 하면서 책을 읽었을 때는 “아 그렇구나…!“ 하고 쭉쭉 읽어 넘기고 너무 추상적으로만 다가와서 개념이 잡힌다는 생각을 하지는 못했어요. 이번에 책을 읽으면서는 책에 나와 있는 예시가 아니라 내 상황에 맞는 다른 예시를 대입해보니 헷갈렸던 개념들이 나오고 이게 맞나? 아닌가? 하며 읽다보니 시간이 참 많이 걸렸어요. 개념들이 나오게 된 이유가 상세히 잘 설명이 되어 있는데 지금은 이 부분이 보여서 좀 신기하기도 했어요. 제대로 잘 모르고 무지성으로 사용하고 있던 개념들을 정리하면서 읽다보니 머리에 더 잘 남는 것 같아요 😎","link":"/2023/10/22/the-essence-of-object-orientation-object/"},{"title":"RESTful API - 리소스 이름은 어떻게 지어야할까?","text":"들어가며샘플 소제목카탈로그 테스트안녕하세요! 이번 글은 API의 리소스명을 어떻게 지어야하는지에 대한 고민 과정에 대해서 공유하고자 합니다. 우선 제가 만들고 있는 서비스에 대해 간략하게 설명드릴게요. 저는 농구 동호회의 어드민 페이지를 만들고 있고 해당 서비스에서 필요한 기능은 크게 두 가지 입니다. 재무 관리 회원 관리 재무 관리 기능은 동호회 모임 통장과 관련한 기능인데요. 가계부 어플을 생각하면 이해하기 쉬울 거예요. 동호회 운영과 관련한 모든 재정적인 활동 내역을 기록하고 조회할 수 있는 기능입니다. 이 글에서는 재무 관리 기능에 대해서만 다룰 거예요. 대쉬보드에 이달의 입금 &amp; 지출 내역 Top3 를 보여주고 싶습니다. 해당 API 엔드포인트를 설계하려고 해요. 그런데 리소스 이름을 어떻게 지어야 할까요? 도메인명으로 작성하면 되지 않나?입출금 내역으로 AccountTransaction 이라는 도메인을 사용하고 있어요. 그렇다면 이달의 입금 내역과 지출 내역을 조회하는 API를 설계할 때 /account-transactions 라는 리소스명을 사용하면 되지 않을까요? 아래와 같이 말이죠. 1. 이달의 입금 내역 상위 3개를 조회하는 APIHTTP Method: GET Endpoint: /account-transactions/deposits/top3 Query Parameters: year: 조회할 연도 (예: 2024) month: 조회할 월 (예: 7) 2. 이달의 지출 내역 상위 3개를 조회하는 APIHTTP Method: GET Endpoint: /account-transactions/expenses/top3 Query Parameters: year: 조회할 연도 (예: 2024) month: 조회할 월 (예: 7) 도메인의 관계가 이렇다면? 모임 통장에서 발생하고 있는 내역을 분류하면 위의 그림과 같아요. 입금 내역 A,B,C와 출금 내역 D,E 라고 설명하겠습니다. 입금 내역 A가 저장이 되면 입출금 내역에 A의 고유 ID와 트랜잭션 타입이 저장됩니다. 입금 내역 A를 조회하고 싶다면 A 테이블을 조회해서 데이터를 가져옵니다. 입출금 내역 테이블에 A의 데이터가 저장되어 있는 게 아니라 테이블의 속성으로 고유 ID와 트랜잭션 타입이 저장되어 있는데 이런 상황에도 /account-transactions 라는 리소스명을 사용해도 되는지 혼란이 왔습니다. API 사용자의 입장에서 생각해볼까?관점을 바꿔서 생각해봅시다. API 엔드포인트의 네이밍은 특정 도메인 객체가 직접적으로 데이터를 포함하고 있는지 여부보다는 리소스의 의미와 API 사용자에게 전달하는 메시지가 중요해요. /account-transactions 를 사용하는 API 사용자의 입장에서 해당 엔드포인트는 어떨까요? 계좌의 거래내역과 관련한 정보를 요청하고 있다 계좌 거래내역이 입금 및 출금과 관련한 메타데이터를 관리하고 있다 계좌 거래 내역의 입금 및 출금 데이터 중 상위 3개의 데이터를 반환한다 2024년, 7월을 파라미터로 전달한다면 2024년 7월 입금 및 출금 데이터 중에서 상위 3개의 데이터를 확인할 수 있다 원하는 결과값을 어느 테이블에서 들고 오느냐는 API 사용자의 관심사가 아닙니다. API 사용자가 원하는 결과값을 어떤 방식으로 구현하느냐는 API 제공자의 역할이에요. API 사용자는 결과값을 요청하는 것이 주된 관심사입니다. 따라서 API를 설계할 때는 API 사용자에게 직관적이고 명확한 경험을 제공해주는 것이 중요합니다. 마무리하며API를 만들 때 했던 고민을 글로 정리해 보니 음… 별거 아니게 느껴지네요. 간단하게 결론이 지어졌어요.사용자의 입장으로 돌아가자!서비스의 요구사항들이 입출금 내역으로부터 파생되기 때문에 설계를 할 때도 너무 입출금 내역에만 중점을 뒀던 것 같아요. AccountTransaction 도메인은 처음엔 AccountBook 이었다가 AccountLog 가 되기도 했고 필요한 속성들도 수시로 바뀌었습니다. 도메인도 AccountTransaction(입출금 내역), Deposit(입금 내역), Withdrawal(출금 내역) 로 정했다가 계속해서 변경되었어요. 서비스의 요구사항과 목적을 제대로 정립하지 않아서 하나의 도메인이 여러 책임을 담당하게 되고 때문에 도메인의 변경이 잦아졌습니다. 그에따라 API 엔드포인트도 변경을 해야만 했어요. 서비스의 요구사항을 제대로 정립하기 위해선 도메인 탐구가 선행되어야겠다는 판단을 하게 됐습니다. 다음에는 도메인을 탐구하는 과정에서 생긴 일들을 공유하게 되면 좋겠습니다!","link":"/2024/09/04/how-to-name-resources-in-restful-apis-md/"}],"tags":[{"name":"혼자공부하는컴퓨터구조","slug":"혼자공부하는컴퓨터구조","link":"/tags/%ED%98%BC%EC%9E%90%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"},{"name":"mysql, order by, group by, rank, partition by","slug":"mysql-order-by-group-by-rank-partition-by","link":"/tags/mysql-order-by-group-by-rank-partition-by/"},{"name":"오브젝트, 객체, 설계","slug":"오브젝트-객체-설계","link":"/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EA%B0%9D%EC%B2%B4-%EC%84%A4%EA%B3%84/"},{"name":"객체지향의 사실과 오해, 추상화, 다형성, 독후감","slug":"객체지향의-사실과-오해-추상화-다형성-독후감","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-%EC%B6%94%EC%83%81%ED%99%94-%EB%8B%A4%ED%98%95%EC%84%B1-%EB%8F%85%ED%9B%84%EA%B0%90/"},{"name":"객체지향의 사실과 오해, 독후감","slug":"객체지향의-사실과-오해-독후감","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-%EB%8F%85%ED%9B%84%EA%B0%90/"},{"name":"RESTfulAPI","slug":"RESTfulAPI","link":"/tags/RESTfulAPI/"}],"categories":[{"name":"개발서적","slug":"개발서적","link":"/categories/%EA%B0%9C%EB%B0%9C%EC%84%9C%EC%A0%81/"},{"name":"혼자공부하는컴퓨터구조","slug":"개발서적/혼자공부하는컴퓨터구조","link":"/categories/%EA%B0%9C%EB%B0%9C%EC%84%9C%EC%A0%81/%ED%98%BC%EC%9E%90%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"}],"pages":[]}