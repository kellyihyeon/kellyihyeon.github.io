---
title: 객체지향의 사실과 오해 - 객체편
date: 2023-10-22 11:31:16
tags: 객체지향의 사실과 오해, 독후감
---
# 이 책을 고른 이유

취준생 시절에 읽었었던 책이지만 머리에 남아있는 게 없어서 다시 한번 읽어보려고 이 책을 선택했어요. 개발자로 일하고 있는 지금 이 책을 읽었을 때 이해도가 많이 다를까 궁금하기도 해서 내 상황에 맞게 예시를 적용해가며 책을 읽어가던 중 핵심적인 부분은 내용을 정리해 놓고 주기적으로 다시 살펴보면 좋을 것 같아서 글로 정리를 해보려 합니다.

# 이상한 나라의 객체

## 현실세계에서의 객체

지금 당장 제 주변에 있는 객체를 말해보라고 한다면? 저는 노트북, 책, 독서대, 컵, 휴대폰, 안경 케이스, 이어폰, 커피머신 이라고 말할 수 있어요. 눈에 보이는 더 많은 객체들을 말할 수가 있는데요. 이렇게 **하나의 단위로 인식할 수 있고 다른 사물과 구분할 수 있는 것**들을 객체라고 부릅니다. 그리고 인간은 이 이상을 넘어 개념적으로 경계 지을 수 있는 추상적인 사물까지도 객체로 인식할 수가 있어요. 예를 들어볼게요, 제가 지금 열심히 참여하고 있는 농구 클래스의 출석 명단을 예로 들 수 있을 거 같아요. 회원들은 저번주 출석 명단과 이번주 출석 명단을 구분할 수 있고, 저번주와 이번주의 출석률도 비교할 수 있어요. 같은 회원이 저번주와 이번주에 모두 참여한다고 하더라도 두 출석 명단을 구분하고 비교하는 일은 아주 쉽습니다. 출석과 출석률은 물리적인 실체가 없지만 우리는 이를 쉽게 구분할 수 있고 하나의 단위로 인식할 수 있는 개념적인 객체라고 볼 수 있어요.

💡 요약해보면, **객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것** 입니다.

## 객체지향 나라에서의 객체

책에서 객체를 어떻게 정의를 하고 있는지 살펴보면 아래와 같아요.

```
객체란 식별 가능한 개체 또는 사물이다. 
객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다.
객체는 구별 가능한 **식별자**, 특징적인 **행동**, 변경 가능한 **상태**를 가진다.
소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.
```

객체를 설명하는 데 중요한 3가지 키워드가 나와있는데요, **‘식별자, 행동, 상태’** 이 개념들을 알아볼까요?

### 상태

객체가 왜 상태를 가지고 있어야 하는지 그 필요성에 대해서 생각해보아요. 객체는 주변 환경에 어떻게 반응할까요? 객체가 어떻게 반응할 것인지는 객체가 행동을 결정하려는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우됩니다. 예를 들어서 설명해 볼게요. H는 농구 클래스 수업을 듣고 있고 또 어느 농구 팀에 소속되어 있습니다. 농구 클래스는 레벨이 5까지 있고, 하위 레벨로 이동하는 것은 제약이 없지만 상위 레벨로 가려면 각 레벨 테스트에 통과를 해야합니다.

이 예시에서 출발해보도록 합시다. 농구 클래스 수업을 들으려면 수업 시작일 전까지 해당 레벨 클래스를 결제해야 합니다. 클래스를 결제하기 위해서는 사이트에 회원가입을 먼저 해야 하고요. 이렇듯 어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존하고 있어요.

‘H가 농구 클래스를 듣는다’ 라는 행동의 결과를 예상할 수 있는 한 가지 방법은 H가 과거 해당 클래스를 결제한 적이 있는지를 살펴보는 것인데요. 이 방법의 단점이 있습니다. 복잡해요. H가 과거에 했던 모든 행동을 타고타고 내려가서 과거의 행동 이력을 기억해야 하기 때문에 이 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 우선 복잡합니다. 그리고 너무 번거로워요.

이 점을 단순하게 풀어내기 위해 **상태**라는 개념이 나오게 됩니다. 다시 예로 돌아가보죠.  H의 클래스 수강 가능 여부는 H의 클래스 결제 상태를 보고 예측할 수 있습니다. 과거의 이력을 기억하지 않아도 돼요. 결제 상태가 YES 이기만 하면 되는 거죠. 조금 더 구체적으로 예를 들어 H의 현재 레벨이 5라고 가정해봅시다. 레벨 5는 레벨 4를 3개월 이상 수강해야만 올라갈 수 있습니다.  H가 레벨 5 클래스를 수강하고 있다는 행동의 결과는 H가 과거에 어떤 행동을 했었는지는 몰라도 되는 거죠. H의 현재 레벨 상태와 해당 클래스의 수강 기간 상태라는 두 가지 상태만 알면 H가 레벨 5 클래스를 듣는 행동의 결과를 쉽게 예측할 수 있어요.

```
상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.
상태는 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다.
```

**상태와 프로퍼티**

상태를 설명할 때 예로 든 개념을 다시 살펴볼게요. 첫번째로 H는 객체입니다. 그리고 H가 구매한 농구 클래스 역시 객체입니다. H가 소속되어 있는 팀 역시 객체입니다. H & 농구 클래스 & 소속팀은 제각각 뚜렷한 경계를 가지고 있어요. 식별이 가능하고 상태와 행동을 모두 가지고 있습니다.

하지만 H의 ‘레벨 상태’와 ‘테스트 통과 여부’ 는 어떨까요? 이들 역시도 제각각 뚜렷한 경계를 가지고 있고 식별이 가능합니다. 하지만 객체가 아닙니다.  숫자, 문자열, 시간, 날짜 참/거짓과 같은 단순한 값들은 객체가 아니에요. 단순한 값들은 다른 객체의 상태를 표현하기 위해 사용되기 때문이에요. H의 레벨 상태는 단순한 숫자 값으로 표현할 수 있어요. 테스트 통과 여부는 참/거짓으로 표현할 수 있고, H의 수강 기간은 날짜 혹은 시간으로 표현할 수 있어요. 이들은 객체는 아니지만 객체의 상태를 표현하고 있습니다.

이번엔 H가 어떤 클래스를 수강하고 있는지를 표현해보도록 해요. 어떻게 표현해야 할까요? 제일 간단하게 표현하는 방법은 H의 상태 일부를 농구 클래스 수강권 객체를 이용해 표현하는 것입니다. H와 농구 클래스를 연결시키는 것이죠.

객체지향 관점에서 ‘연결’ 이라는 것은 ‘알고 있다’ 라는 의미로 사용을 합니다. H와 농구 클래스를 연결하면 아래의 그림과 같아요.

![연결된 상태](../image/%EC%83%81%ED%83%9C%EC%99%80%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B01.png)

H와 농구 클래스 수강권은 객체 입니다. 하지만 H의 레벨과 테스트 통과 여부, 농구 클래스의 레벨과 가격은 객체가 아니라 단순한 값에 불과해요. 상태 얘기를 하면서 객체와 단순한 값 그리고 또 다른 객체 얘기를 늘어놓고 있는데요. 정리를 해보자면 H의 상태는 레벨과 테스트 통과 여부라는 단순한 값과 농구 클래스라는 객체의 조합으로 표현할 수 있어요. 그림을 딱 보고 H의 상태를 이렇게 설명할 수 있어요. 
”H는 현재 레벨이 4이고 테스트를 통과하였으며 2023년 10월 1일 ~ 31일까지 유효한 10만원 짜리 레벨 5 농구 클래스 수강권을 가지고 있다.”

```
모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있다. 
이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다.
```

H의 프로퍼티를 찾아볼까요? H의 현재 레벨, 테스트 통과 여부, 농구 클래스 수강권. 이들을 프로퍼티라고 불러요. 그렇다면 5, false, 100000, 2023.10.01, 2023.10.31 같은 단순한 값들은 뭐라고 불러야 할까요? 이들을 프로퍼티 값(property value) 이라고 부릅니다. 프로퍼티 값은 시간이 흐르면 변경되는 값이기 때문에 동적입니다. 프로퍼티는 시간이 흘러도 변경되지 않고 고정되기 때문에 정적이고요.

시간이 흐르면 값이 변경된다?  다른 시점에서 H의 상태를 한번 살펴보도록 합시다.

![연결되지 않은 상태](../image/%EC%83%81%ED%83%9C%EC%99%80%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B02.png)

H는 레벨 5가 되었지만 테스트는 통과하지 못했어요. 그리고 지금은 농구 클래스를 수강하고 있지 않은 것 같아요.

클래스를 수강하고 있냐 아니냐는 선의 여부를 보면 알 수 있어요. H 객체와 농구 클래스 수강권 객체 사이가 연결이 되어 있었는데 위의 그림에서는 연결이 되어 있지 않아요. 우리는 이 연결을 객체가 다른 객체를 ‘알고 있다’ 라고 표현해요. 그리고 이 연결은 중요한데요. 객체와 객체 사이에 연결이 되어 있어야 다른 객체에게 메세지를 요청할 수가 있기 때문이에요. 연결은 다른 객체를 **참조**할 수 있다는 것을 의미하고 이는 즉, 다른 객체의 **식별자**를 알고 있는 것을 의미합니다. 

그리고 위에서 설명한 단순한 값에 불과한 H의 레벨과 테스트 통과 여부, 농구 클래스 수강권의 가격 등등을 **속성(attribute)** 이라고 부릅니다.

```
객체의 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두 가지 종류의 조합으로 표현할 수 있다.
```

### 행동

객체는 자율적인 존재입니다. 객체 스스로 행동해서 자신의 상태를 변경합니다. 외부 객체는 절대로 직접적으로 다른 객체의 상태를 멋대로 변경할 수 없습니다. 하지만 우리에게 주어진 문제를 해결하기 위해서는 객체와 객체가 서로 협력 해야만 해결할 수 있는데요. 이를 위해 외부 객체가 간접적으로 다른 객체의 상태를 변경하거나 볼 수 있는 방법이 필요합니다. 그래서 **행동** 이라는 개념이 나타난 것이죠.

객체의 상태를 설명하면서 다른 객체에게 **메세지를 요청** 한다고 언급한 적이 있습니다. 객체가 다른 객체와 협력하는 방법이 메세지를 요청하는 것입니다. 메세지를 통해서만 협력할 수 있어요. 복잡한 문제를 해결하기 위해서는 객체가 다른 객체에게 메세지를 요청하면서 연쇄 요청 작업이 일어나게 되는데요. 메세지를 수신한 객체는 메세지를 읽고 협력에 참여할 것인지, 참여한다면 어떤 방법으로 해당 메세지에 대한 응답을 줄 것인지를 스스로 결정하게 됩니다. 행동을 함으로써 자신의 상태를 변경하는 것이죠.

```
행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다.
행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 베시지를 전달 할 수 있다.
객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.
```

**상태 캡슐화**

객체지향 나라에서의 객체와 현실의 객체 사이에서 중요한 차이점은 객체의 자율화입니다. 현실에서 H와 수강권 중에 능동적인 주체를 택하라 한다면 당연히 H를 택할 거예요. 수강을 할지 말지는 H의 의지이며 H가 수강하기로 했다면 수강권을 결제하는 주체 또한 H이기 때문이죠.
그렇다면 객체지향 나라에서 능동적인 주체는 누구일까요? 모든 객체입니다.
H의 레벨 상태와 테스트 통과여부를 결정하는 주체는 H 입니다. 수강권 객체도 마찬가지인데요. 수강권 객체는 H로부터 메세지를 요청 받으면  발권 여부를 스스로 결정합니다. 발권 시 시작일과 종료일 또한 스스로 설정하여 메세지에 대한 응답을 돌려줍니다. 발권을 할지 말지는 수강권 객체 스스로가 결정할 사항이며 H 객체가 발권 행위에 직접 개입할 수 없습니다. H 객체는 수강권 객체에 자신의 레벨 상태를 전달하고 응답을 기다리는 역할을 할 뿐이에요. 

H 객체와 수강권 객체 사이에 어떤 메세지가 오고가는지 살펴볼까요?

![메세지 요청](../image/%ED%96%89%EB%8F%99.png)

H 객체에게는 `doLevelTest()` 라는 메세지가 요청이 되었고, 수강권 객체 에게는 `doneLevelTest(level)` 라는 메세지가 요청이 되었어요. 메세지를 요청한 객체 입장에서 생각해 봅시다. 메세지를 전달하였으니 어떤 상태가 변경되겠지? 라고 예상할 수 있을까요? 전혀 예상할 수가 없습니다. H의 레벨과 테스트 통과여부가 어떻게 변경되었는지, 수강권은 또 어떻게 변했는지 알 수 없어요. 사실 메세지를 전달했을 때 상태가 변경될 거라는 사실조차 알 수가 없어요. 이게 바로 **캡슐화** 입니다!

```
객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다.
객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.

상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.
이것이 상태를 캡슐화해야 하는 이유다.
```

### 식별자

개념적인 객체를 설명하면서 예시로 든 출석 명단을 생각해봅시다. 지난주의 출석 명단과 이번주의 출석 명단은 같은 출석 명단 객체입니다. 이 두 객체를 서로 어떻게 구별할까요? 이때 나오는 개념이 **식별자** 입니다. 객체를 식별할 수 있다는 것은 두 객체가 서로 다른 객체임을 구별할 수 있는 프로퍼티가 객체 내부에 있다는 의미입니다. 이 프로퍼티를 식별자라고 불러요. 객체들은 식별자를 가지고 있고, 식별자로 서로를 구별할 수 있습니다.

여기에서 단순한 값과 객체의 차이점이 생기는데요. 단순한 값은 식별자를 가지지 않아요. 중요한 차이점 입니다. 단순한 값과 객체의 차이점에 대해서 좀 더 살펴봅시다.

**단순한 값**

값의 상태는 변하지 않기 때문에 불변 상태를 가진다고 말합니다. 값이 같은지를 판단할 때는 **상태**를 기준으로 판단해요. 값의 상태가 예를 들어 1이라고 한다면, 1 = 1은 같기 때문에 두 인스턴스를 같은 것으로 판단합니다. 상태를 이용해서 두 값이 같은지 판단할 수 있는 성질을 **동등성(equality)** 이라고 해요. 상태로 판단할 수 있는 이유는 상태는 변하지 않기 때문이죠. 이처럼 값은 상태를 이용해 동등성을 판단하기 때문에 인스턴스를 구별하기 위해서 식별자가 필요하지 않아요.

**객체**

객체는 시간에 따라 상태가 변경되기 때문에 가변 상태를 가진다고 말합니다. H 로 예를 들어볼게요. H와 상태가 완전히 똑같은 S 가 있습니다. H와 S의 상태는 완전히 동일한데요. 그렇다면 두 회원은 동일인물 인가요? 완전 다른 사람이죠. 그리고 시간이 지난다면 어떻게 될까요? 그 때도 완전히 동일한 상태일 거라고 확신할 수 있을까요? 변할 수 있겠죠. 때문에 객체는 식별자가 필요해요. H와 S의 상태가 같더라도 식별자를 보고 두 객체는 다르다 라고 말할 수 있어요.  아래의 그림을 보면서 반대의 경우도 생각해볼까요?  

![인스턴스 비교](../image/%EC%8B%9D%EB%B3%84%EC%9E%90_%EA%B0%9D%EC%B2%B4.png)

두 객체의 상태가 다르죠. 이 두 객체는 서로 다른 객체일까요? 그림만 보고서는 알 수가 없어요. 식별자를 봐야해요. 식별자가 같으면 두 객체는 같은 객체입니다. 식별자를 이용해서 객체가 같은지 판단할 수 있는 성질을 **동일성(identical)** 이라고 해요.

<aside>
💡 용어 정리

값 객체(String, Integer, Long…)는 식별자를 가지지 않기 때문에 여기에서 언급하는 객체란 **참조 객체(reference object)** 를 의미합니다. 

</aside>

# 마치며

취준 하면서 책을 읽었을 때는 “아 그렇구나…!“ 하고 쭉쭉 읽어 넘기고 너무 추상적으로만 다가와서 개념이 잡힌다는 생각을 하지는 못했어요. 이번에 책을 읽으면서는 책에 나와 있는 예시가 아니라 내 상황에 맞는 다른 예시를 대입해보니 헷갈렸던 개념들이 나오고 이게 맞나? 아닌가? 하며 읽다보니 시간이 참 많이 걸렸어요.

개념들이 나오게 된 이유가 상세히 잘 설명이 되어 있는데 지금은 이 부분이 보여서 좀 신기하기도 했어요. 제대로 잘 모르고 무지성으로 사용하고 있던 개념들을 정리하면서 읽다보니 머리에 더 잘 남는 것 같아요 😎